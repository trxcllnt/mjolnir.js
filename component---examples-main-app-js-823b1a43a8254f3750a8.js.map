{"version":3,"sources":["webpack:///../src/utils/hammer-overrides.js","webpack:///../src/utils/hammer.browser.js","webpack:///../src/constants.js","webpack:///../src/inputs/wheel-input.js","webpack:///../src/inputs/move-input.js","webpack:///../src/inputs/key-input.js","webpack:///../src/inputs/contextmenu-input.js","webpack:///../src/utils/event-utils.js","webpack:///../src/utils/event-registrar.js","webpack:///../src/event-manager.js","webpack:///../examples/main/constants.js","webpack:///../examples/main/app.js","webpack:///../node_modules/hammerjs/hammer.js","webpack:///../src/utils/globals.js"],"names":["PointerEventInput","oldHandler","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","hammerjs","enhancePointerEventInput","ev","store","this","array","i","predict","some","e","enhanceMouseInput","MouseInput","eventType","pressed","callback","pointers","changedPointers","pointerType","srcEvent","Manager","RECOGNIZERS","Hammer","event","threshold","enable","taps","RECOGNIZER_COMPATIBLE_MAP","tripan","rotate","pinch","pan","doubletap","anytap","RECOGNIZER_FALLBACK_MAP","BASIC_EVENT_ALIASES","pointerdown","pointermove","pointerup","touchstart","touchmove","touchend","INPUT_EVENT_TYPES","EVENT_RECOGNIZER_MAP","tap","press","pinchin","pinchout","pinchstart","pinchmove","pinchend","pinchcancel","rotatestart","rotatemove","rotateend","rotatecancel","tripanstart","tripanmove","tripanup","tripandown","tripanleft","tripanright","tripanend","tripancancel","panstart","panmove","panup","pandown","panleft","panright","panend","pancancel","swipe","swipeleft","swiperight","swipeup","swipedown","GESTURE_EVENT_ALIASES","click","anyclick","dblclick","mouseover","mouseout","mouseleave","firefox","userAgent","WHEEL_EVENTS","WheelInput","options","element","Object","events","handleEvent","bind","forEach","passiveSupported","passive","destroy","enableEventType","value","window","wheelPosition","x","y","clientY","Math","_onWheel","type","center","delta","target","MOUSE_EVENTS","MoveInput","enableMoveEvent","enableLeaveEvent","enableOutEvent","enableOverEvent","handleOverEvent","handleOutEvent","handleLeaveEvent","handleMoveEvent","KEY_EVENTS","KeyInput","enableDownEvent","enableUpEvent","targetElement","key","ContextmenuInput","removeEventListener","DEFAULT_OPTIONS","srcElement","priority","EventRegistrar","eventManager","handlers","handlersByElement","_active","isEmpty","add","once","opts","entries","entry","handler","insertPosition","remove","mjolnirEvent","_normalizeEvent","_emit","get","immediatePropagationStopped","stopPropagation","stopImmediatePropagation","entriesToRemove","rootElement","buttons","button","which","leftButton","middleButton","rightButton","Number","Boolean","whichButtons","rect","scaleX","scaleY","offsetCenter","getOffsetPosition","handled","recognizers","recognizerOptions","touchAction","tabIndex","EventManager","_onBasicInput","_onOtherEvent","setElement","on","ManagerClass","manager","name","recognizer","otherName","recognizerOption","wheelInput","moveInput","keyInput","contextmenuInput","eventAlias","eventRegistrar","_toggleRecognizer","_addEventHandler","watch","off","_removeEventHandler","enabled","fallbackRecognizers","otherRecognizer","eventName","recognizerName","isRecognizerUsed","eh","alias","emit","EVENTS","INITIAL_OPTIONS","wheel","App","eventListeners","_onLoad","_eventManager","ref","_onLoadRedBox","_redBox","_onUpdateOption","evt","checked","setState","state","_handleEvent","slice","_renderCheckbox","id","onChange","htmlFor","_renderEvent","index","render","Component","renderToDOM","container","document","exportName","undefined","assign","VENDOR_PREFIXES","TEST_ELEMENT","createElement","round","abs","now","Date","setTimeoutContext","fn","timeout","context","setTimeout","bindFn","invokeArrayArg","arg","Array","isArray","each","obj","iterator","length","call","hasOwnProperty","deprecate","method","message","deprecationMessage","Error","stack","replace","log","console","warn","apply","arguments","TypeError","output","source","nextKey","extend","dest","src","merge","keys","inherit","child","base","properties","childP","baseP","prototype","create","constructor","_super","boolOrFn","val","args","ifUndefined","val1","val2","addEventListeners","types","splitStr","addEventListener","removeEventListeners","hasParent","node","parent","parentNode","inStr","str","find","indexOf","trim","split","inArray","findByKey","toArray","uniqueArray","sort","results","values","push","a","b","prefixed","property","prefix","prop","camelProp","toUpperCase","_uniqueId","getWindowForElement","doc","ownerDocument","defaultView","parentWindow","SUPPORT_TOUCH","SUPPORT_POINTER_EVENTS","SUPPORT_ONLY_TOUCH","test","navigator","PROPS_XY","PROPS_CLIENT_XY","Input","self","inputTarget","domHandler","init","inputHandler","input","pointersLen","changedPointersLen","isFirst","isFinal","session","pointersLength","firstInput","simpleCloneInputData","firstMultiple","getCenter","timeStamp","deltaTime","angle","getAngle","distance","getDistance","offset","offsetDelta","prevDelta","prevInput","deltaX","deltaY","computeDeltaXY","offsetDirection","getDirection","overallVelocity","getVelocity","overallVelocityX","overallVelocityY","scale","start","end","rotation","getRotation","maxPointers","velocity","velocityX","velocityY","direction","last","lastInterval","v","computeIntervalInputData","computeInputData","recognize","clientX","p1","p2","props","sqrt","atan2","PI","evEl","evTarget","evWin","POINTER_INPUT_MAP","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","2","3","4","5","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","pointerEvents","MSPointerEvent","PointerEvent","removePointer","eventTypeNormalized","toLowerCase","isTouch","storeIndex","pointerId","splice","SINGLE_TOUCH_INPUT_MAP","touchcancel","SingleTouchInput","started","normalizeSingleTouches","all","touches","changed","changedTouches","concat","TOUCH_INPUT_MAP","TouchInput","targetIds","getTouches","allTouches","identifier","targetTouches","changedTargetTouches","filter","touch","TouchMouseInput","mouse","primaryTouch","lastTouches","recordTouches","eventData","setLastTouch","lastTouch","lts","isSyntheticEvent","t","dx","dy","inputEvent","inputData","isMouse","sourceCapabilities","firesTouchEvents","PREFIXED_TOUCH_ACTION","style","NATIVE_TOUCH_ACTION","TOUCH_ACTION_MAP","touchMap","cssSupports","CSS","supports","getTouchActionProps","TouchAction","set","compute","actions","update","getTouchAction","hasPanX","hasPanY","cleanTouchActions","join","preventDefaults","prevented","preventDefault","hasNone","isTapPointer","isTapMovement","isTapTouchTime","DIRECTION_LEFT","DIRECTION_UP","preventSrc","Recognizer","defaults","simultaneous","requireFail","stateStr","directionStr","getRecognizerByNameIfManager","AttrRecognizer","PanRecognizer","pX","pY","PinchRecognizer","PressRecognizer","_timer","_input","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","preset","recognizeWith","dropRecognizeWith","requireFailure","dropRequireFailure","hasRequireFailures","canRecognizeWith","additionalEvent","tryEmit","canEmit","inputDataClone","reset","process","attrTest","optionPointers","isRecognized","isValid","DIRECTION_HORIZONTAL","directionTest","hasMoved","inOut","time","validPointers","validMovement","validTime","clearTimeout","interval","posThreshold","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","VERSION","domEvents","inputClass","cssProps","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","oldCssProps","toggleCssProps","item","stop","force","stopped","curRecognizer","existing","data","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","triggerDomEvent","INPUT_START","INPUT_MOVE","INPUT_END","INPUT_CANCEL","STATE_POSSIBLE","STATE_BEGAN","STATE_CHANGED","STATE_ENDED","STATE_RECOGNIZED","STATE_CANCELLED","STATE_FAILED","DIRECTION_NONE","DIRECTION_RIGHT","DIRECTION_DOWN","DIRECTION_VERTICAL","DIRECTION_ALL","Tap","Pan","Swipe","Pinch","Rotate","Press","window_","global"],"mappings":";mNA+ByCA,EACjCC,E,8EAvBFC,EAAkB,CACtBC,UAJF,EAKEC,UAJF,EAKEC,QAJF,GAuByCL,EC5BhBM,IAAzBC,kBD6BQN,EAAaD,YADuC,QAI1DA,oBAAsC,SAAiBQ,GACrD,IAAMC,EAAQC,KAD2C,MAIrDF,SAAJ,IAlBJ,SAAcG,EAAM,GAClB,IAAK,IAAIC,EAAT,EAAgBA,EAAID,EAApB,OAAkCC,IAChC,GAAIC,EAAQF,EAAZC,IACE,OAAO,EAGX,OAAO,EAaEE,CAAKL,GAAO,SAAAM,GAAC,OAAIA,cAAgBP,EAApB,cAChBC,WAIJR,gBCzCcK,IAAlBU,WD+CEC,kBAA+B,SAAiBT,GAC9C,IAAIU,EAAYhB,EAAgBM,EADkB,MA7CtD,EAiDQU,GAA2BV,UAA/B,IACEE,KAAKS,SAAL,GAjDN,EAoDQD,GAAJ,IAA8BV,UAC5BU,EApDN,GAwDSR,KAAL,UAxDJ,EA4DQQ,IACFR,KAAKS,SAAL,GAGFT,KAAKU,SAASV,KAAd,UAAuC,CACrCW,SAAU,CAD2B,GAErCC,gBAAiB,CAFoB,GAGrCC,YAHqC,QAIrCC,SAAUhB,MCtET,IAAMiB,EAAUnB,IAAhB,QAEP,MCgBaoB,EAAcC,EACvB,CACE,CAACA,EAAD,IAAa,CAACC,MAAD,SAAkBP,SAAlB,EAA+BQ,UAA/B,EAA6CC,QAAQ,IAClE,CAACH,EAAD,OAAgB,CAACG,QAAQ,IACzB,CAACH,EAAD,MAAe,CAACG,QAAQ,IACxB,CAACH,EAAD,MAAe,CAACG,QAAQ,IACxB,CAACH,EAAD,IAAa,CAACE,UAAD,EAAeC,QAAQ,IACpC,CAACH,EAAD,MAAe,CAACG,QAAQ,IACxB,CAACH,EAAD,IAAa,CAACC,MAAD,YAAqBG,KAArB,EAA8BD,QAAQ,IAEnD,CAACH,EAAD,IAAa,CAACC,MAAD,SAAkBE,QAAQ,IACvC,CAACH,EAAD,IAAa,CAACG,QAAQ,KAXrB,KAgBME,EAA4B,CACvCC,OAAQ,CAAC,SAAS,QADqB,OAEvCC,OAAQ,CAF+B,SAGvCC,MAAO,CAHgC,OAIvCC,IAAK,CAAC,QAAQ,YAAT,SAJkC,OAKvCC,UAAW,CAL4B,UAMvCC,OAAQ,CAAC,QAIEC,EAA0B,CACrCF,UAAW,CAAC,QAUDG,EAAsB,CACjCC,YADiC,cAEjCC,YAFiC,cAGjCC,UAHiC,YAIjCC,WAJiC,cAKjCC,UALiC,cAMjCC,SANiC,YAOjC3C,UAPiC,cAQjCC,UARiC,cASjCC,QAAS,aAGE0C,EACC,CAAC,UADkB,SAApBA,EAEG,CAAC,YAAY,YAAb,iCAFiB,cAApBA,EAGG,wCAgBHC,EAAuB,CAClCC,IADkC,MAElCX,OAFkC,SAGlCD,UAHkC,YAIlCa,MAJkC,QAKlCf,MALkC,QAMlCgB,QANkC,QAOlCC,SAPkC,QAQlCC,WARkC,QASlCC,UATkC,QAUlCC,SAVkC,QAWlCC,YAXkC,QAYlCtB,OAZkC,SAalCuB,YAbkC,SAclCC,WAdkC,SAelCC,UAfkC,SAgBlCC,aAhBkC,SAiBlC3B,OAjBkC,SAkBlC4B,YAlBkC,SAmBlCC,WAnBkC,SAoBlCC,SApBkC,SAqBlCC,WArBkC,SAsBlCC,WAtBkC,SAuBlCC,YAvBkC,SAwBlCC,UAxBkC,SAyBlCC,aAzBkC,SA0BlChC,IA1BkC,MA2BlCiC,SA3BkC,MA4BlCC,QA5BkC,MA6BlCC,MA7BkC,MA8BlCC,QA9BkC,MA+BlCC,QA/BkC,MAgClCC,SAhCkC,MAiClCC,OAjCkC,MAkClCC,UAlCkC,MAmClCC,MAnCkC,QAoClCC,UApCkC,QAqClCC,WArCkC,QAsClCC,QAtCkC,QAuClCC,UAAW,SAQAC,EAAwB,CACnCC,MADmC,MAEnCC,SAFmC,SAGnCC,SAHmC,YAInClF,UAJmC,cAKnCC,UALmC,cAMnCC,QANmC,YAOnCiF,UAPmC,cAQnCC,SARmC,aASnCC,WAAY,gB,YC7HRC,GAAN,IAAgBC,uBAETC,EAAgB5C,EASF6C,E,WACnB,kBAA8C,IAAD,gBAAdC,MAAU,IACvCnF,KAAKoF,QAAL,EACApF,KAAKU,SAAL,EAEAV,KAAKmF,QAAUE,OAAA,OAAc,CAACjE,QAAQ,GAAtC,GAEApB,KAAKsF,OAASL,SAAoBE,UAAlC,IAEAnF,KAAKuF,YAAcvF,KAAKuF,YAAYC,KAApCxF,MACAA,KAAKsF,OAAOG,SAAQ,SAAAvE,GAAK,OACvBkE,qBAAgC,EAAhCA,cAAkDM,KAAmB,CAACC,SAAS,O,2BAInFC,mBAAW,IAAD,OACR5F,KAAKsF,OAAOG,SAAQ,SAAAvE,GAAK,OAAI,gCAAwC,EAA5C,iB,EAO3B2E,8BA/BF,UAgCQrF,IACFR,KAAKmF,QAAQ/D,OAAb,I,EAKJmE,wBACE,GAAKvF,KAAKmF,QAAV,QAIA,IAAIW,EAAQ5E,EAAZ,OACI6E,IAAJ,aAEMhB,GAAW7D,cAAoB6E,eAAnC,kBACED,GAASC,IAATD,kBAEE5E,cAAoB6E,eAAxB,iBACED,GA9CR,KAkDI,IAAME,EAAgB,CACpBC,EAAG/E,EADiB,QAEpBgF,EAAGhF,EAAMiF,SAGPL,OAAeA,EAxDvB,gBAwDI,IAGEA,EAAQM,WAAWN,EA3DzB,iBA8DQ5E,YAAJ,IACE4E,GA5DN,KA+DI9F,KAAKqG,SAASnF,GAAd,O,EAGFmF,yBACErG,KAAKU,SAAS,CACZ4F,KA1EN,QA2EMC,OAFY,EAGZC,MAHY,EAIZ1F,SAJY,EAKZD,YALY,QAMZ4F,OAAQ3F,EAAS2F,U,KCnFhBC,EAAgBrE,EAcFsE,E,WACnB,kBAA8C,IAAD,gBAAdxB,MAAU,IACvCnF,KAAKoF,QAAL,EACApF,KAAKU,SAAL,EACAV,KAAKS,SAAL,EAEAT,KAAKmF,QAAUE,OAAA,OAAc,CAACjE,QAAQ,GAAtC,GACApB,KAAK4G,gBAAkB5G,KAAKmF,QAA5B,OACAnF,KAAK6G,iBAAmB7G,KAAKmF,QAA7B,OACAnF,KAAK8G,eAAiB9G,KAAKmF,QAA3B,OACAnF,KAAK+G,gBAAkB/G,KAAKmF,QAA5B,OAEAnF,KAAKsF,OAASoB,SAAoBvB,UAAlC,IAEAnF,KAAKuF,YAAcvF,KAAKuF,YAAYC,KAApCxF,MACAA,KAAKsF,OAAOG,SAAQ,SAAAvE,GAAK,OAAIkE,qBAAgC,EAApC,gB,2BAG3BQ,mBAAW,IAAD,OACR5F,KAAKsF,OAAOG,SAAQ,SAAAvE,GAAK,OAAI,gCAAwC,EAA5C,iB,EAO3B2E,8BAvCF,gBAwCQrF,IACFR,KAAK4G,gBAAL,GAxCN,gBA0CQpG,IACFR,KAAK+G,gBAAL,GA1CN,eA4CQvG,IACFR,KAAK8G,eAAL,GA5CN,iBA8CQtG,IACFR,KAAK6G,iBAAL,I,EAIJtB,wBACEvF,KAAKgH,gBAAgB9F,GACrBlB,KAAKiH,eAAe/F,GACpBlB,KAAKkH,iBAAiBhG,GACtBlB,KAAKmH,gBAAgBjG,I,EAGvB8F,4BACMhH,KAAJ,iBACE,cAAIkB,QACFlB,KAAKU,SAAS,CACZ4F,KAhEV,cAiEUxF,SAFY,EAGZD,YAHY,QAIZ4F,OAAQvF,EAAMuF,U,EAMtBQ,2BACMjH,KAAJ,gBACE,aAAIkB,QACFlB,KAAKU,SAAS,CACZ4F,KA5EV,aA6EUxF,SAFY,EAGZD,YAHY,QAIZ4F,OAAQvF,EAAMuF,U,EAMtBS,6BACMlH,KAAJ,kBACE,eAAIkB,QACFlB,KAAKU,SAAS,CACZ4F,KAxFV,eAyFUxF,SAFY,EAGZD,YAHY,QAIZ4F,OAAQvF,EAAMuF,U,EAMtBU,4BACE,GAAInH,KAAJ,gBACE,OAAQkB,EAAR,MACE,IAAI,YACEA,UAAJ,IAEElB,KAAKS,SAAL,GAEF,MACF,IAAI,YAEF,IAAIS,UAEFlB,KAAKS,SAAL,GAEGT,KAAL,SAGEA,KAAKU,SAAS,CACZ4F,KAvHd,cAwHcxF,SAFY,EAGZD,YAHY,QAIZ4F,OAAQvF,EAAMuF,SAGlB,MACF,IAAI,UACFzG,KAAKS,SAAL,I,KChIH2G,EAAc/E,EAIAgF,E,WACnB,kBAA8C,IAAD,gBAAdlC,MAAU,IACvCnF,KAAKoF,QAAL,EACApF,KAAKU,SAAL,EAEAV,KAAKmF,QAAUE,OAAA,OAAc,CAACjE,QAAQ,GAAtC,GACApB,KAAKsH,gBAAkBtH,KAAKmF,QAA5B,OACAnF,KAAKuH,cAAgBvH,KAAKmF,QAA1B,OAEAnF,KAAKsF,OAAS8B,SAAkBjC,UAAhC,IAEAnF,KAAKuF,YAAcvF,KAAKuF,YAAYC,KAApCxF,MAEAoF,WAAmBD,YAAnBC,EACAA,uBACApF,KAAKsF,OAAOG,SAAQ,SAAAvE,GAAK,OAAIkE,qBAAgC,EAApC,gB,2BAG3BQ,mBAAW,IAAD,OACR5F,KAAKsF,OAAOG,SAAQ,SAAAvE,GAAK,OAAI,gCAAwC,EAA5C,iB,EAO3B2E,8BA7BF,YA8BQrF,IACFR,KAAKsH,gBAAL,GA9BN,UAgCQ9G,IACFR,KAAKuH,cAAL,I,EAIJhC,wBAEE,IAAMiC,EAAgBtG,UAAgBA,EAAtC,WAEGsG,qBAAD,SAAsCA,QADxC,aAEEA,YAKExH,KAAKsH,iBAAT,YAA4BpG,QAC1BlB,KAAKU,SAAS,CACZ4F,KAlDR,UAmDQxF,SAFY,EAGZ2G,IAAKvG,EAHO,IAIZuF,OAAQvF,EAAMuF,SAIdzG,KAAKuH,eAAT,UAA0BrG,QACxBlB,KAAKU,SAAS,CACZ4F,KA1DR,QA2DQxF,SAFY,EAGZ2G,IAAKvG,EAHO,IAIZuF,OAAQvF,EAAMuF,W,KC/DDiB,E,WACnB,uBAA6C,IAAdvC,MAAU,IACvCnF,KAAKoF,QAAL,EACApF,KAAKU,SAAL,EAEAV,KAAKmF,QAAUE,OAAA,OAAc,CAACjE,QAAQ,GAAtC,GAEApB,KAAKuF,YAAcvF,KAAKuF,YAAYC,KAApCxF,MACAoF,iCAAwCpF,KAAxCoF,a,2BAGFQ,mBACE5F,KAAKoF,QAAQuC,oBAAoB,cAAe3H,KAAhD,c,EAOF6F,8BArBF,gBAsBQrF,IACFR,KAAKmF,QAAQ/D,OAAb,I,EAIJmE,wBACOvF,KAAKmF,QAAV,QAIAnF,KAAKU,SAAS,CACZ4F,KAjCN,cAkCMC,OAAQ,CACNN,EAAG/E,EADG,QAENgF,EAAGhF,EAAMiF,SAEXrF,SANY,EAOZD,YAPY,QAQZ4F,OAAQvF,EAAMuF,U,KCxDdC,EAAe,CACnB3E,YAJF,EAKEC,YAJF,EAKEC,UAJF,EAKExC,UAPF,EAQEC,UAPF,EAQEC,QAPF,GCDA,IAAMiI,EAAkB,CACtBC,WADsB,OAEtBC,SAAU,GAGSC,E,WACnB,cACE/H,KAAKgI,aAAL,EACAhI,KAAKiI,SAFmB,GAIxBjI,KAAKkI,kBAAoB,IAAzB,IAEAlI,KAAKuF,YAAcvF,KAAKuF,YAAYC,KAApCxF,MACAA,KAAKmI,SAAL,E,2BAIFC,mBACE,OAAQpI,KAAR,S,EAGFqI,6BAAwD,IAA/BC,OAAO,QAAwB,IAAjB3C,OAAU,GAAO,IAC/CsC,EAD+C,cACrCC,EADqC,uBAGlDK,IAAS,iBAAOA,GAAqBA,EAAzC,oBAEEA,EAAO,CAACV,WAAYU,IAEtBA,EAAOA,EAAOlD,mBAAH,GAAXkD,EAEA,IAAIC,EAAUN,MAAsBK,EAApC,YACA,IACEC,KACAN,MAAsBK,EAAtBL,eAEF,IAAMO,EAAQ,CAACnC,KAAD,EAAOoC,QAAP,EAAgBb,WAAYU,EAA5B,WAA6CT,SAAUS,EAAKT,UAC1E,IACEW,WAEF,IACEA,cAEFR,UACAjI,KAAKmI,QAAUnI,KAAKmI,UAAYM,EAtBsB,QA2BtD,IADA,IAAIE,EAAiBH,SAArB,EACOG,GAAP,KACMH,eAAoCC,EAAxC,WAGAE,IAEFH,SAAeG,EAAfH,Q,EAGFI,qBAGE,IAHqB,IACdX,EADa,cACHC,EADG,uBAGXhI,EAAI+H,SAAb,EAAkC/H,GAAlC,EAA0CA,IAAK,CAC7C,IAAMuI,EAAQR,EAAd,GAEA,GAAIQ,YAAuBA,YAA3B,EAAsD,CACpDR,cACA,IAAMO,EAAUN,MAAsBO,EAAtC,YACAD,SAAeA,UAAfA,MACA,IAAIA,UACFN,SAAyBO,EAAzBP,aAINlI,KAAKmI,QAAUF,EAAA,MAAc,SAAAQ,GAAK,OAAKA,EAAL,Y,EAMpClD,wBACE,IAAIvF,KAAJ,WAOA,IAHA,IAAM6I,EAAe7I,KAAK8I,gBAA1B,GACIrC,EAASvF,WAAb,OAEOuF,GAAUA,IAAWoC,EAA5B,aAAsD,CAEpD,GADA7I,KAAK+I,MAAMF,EAAa,GACpBA,EAAJ,QACE,OAEFpC,EAASA,EAATA,WAEFzG,KAAK+I,MAAMF,EAAa,U,EAM1BE,oBACE,IAAMP,EAAUxI,KAAKkI,kBAAkBc,IAAvC,GAEA,KAAa,CAcX,IAbA,IAAIC,GADO,EAILC,EAAkB,WACtBhI,cAGIiI,EAA2B,WAC/BjI,aACA+H,MAEIG,EAAN,GAESlJ,EAAT,EAAgBA,EAAIsI,EAApB,OAAoCtI,IAAK,CAAC,IAAD,EACTsI,EADS,GAChClC,EADgC,OAC1BoC,EAD0B,UACjBJ,EADiB,OAYvC,GAVAI,EACErD,OAAA,YAAyB,CACvBiB,KADuB,EAEvB4C,gBAFuB,EAGvBC,8BAGJ,GACEC,OAAqBZ,EAArBY,IAEF,EACE,MAIJ,IAAK,IAAIlJ,EAAT,EAAgBA,EAAIkJ,EAApB,OAA4ClJ,IAAK,CAAC,IAAD,EACvBkJ,EADuB,GACxC9C,EADwC,OAClCoC,EADkC,UAE/C1I,KAAK4I,OAAO,EAAZ,M,EAQNE,4BACE,IAAMO,EAAcrJ,KAAKgI,aAAzB,QAEA,OAAO3C,OAAA,YDvHJ,SAAsBnE,GAC3B,IAAMV,EAAYkG,EAAaxF,WAA/B,MACA,MAEE,OAAO,KAJyB,MAODA,EAPC,SAO3BoI,EAP2B,UAOlBC,EAPkB,SAOVC,EAPU,QAQ9BC,GAAJ,EACIC,GAAJ,EACIC,GAAJ,EAqBA,OAzDF,IAwCInJ,GAzCJ,IA2CKA,IAA6BoJ,gBAJhC,IAMEH,EAjCJ,IAiCiBD,EACbE,EAjCJ,IAiCmBF,EACfG,EAjCJ,IAiCkBH,GA/ClB,IAgDahJ,GACTiJ,EAAaI,QA7BjB,EA6ByBP,GACrBI,EAAeG,QA5BnB,EA4B2BP,GACvBK,EAAcE,QA9BlB,EA8B0BP,IApD1B,IAqDa9I,IACTiJ,EArCJ,IAqCiBF,EACbG,EArCJ,IAqCmBH,EACfI,EArCJ,IAqCkBJ,GAGT,CAACE,WAAD,EAAaC,aAAb,EAA2BC,eCwFAG,CAAzB,GDlFJ,SAA2B5I,EAAM,GAAe,IAC9CJ,EAAYI,EADiC,SAIpD,IAAKA,EAAD,SAAkB0I,gBAAgB9I,EAAtC,SAEE,OAAO,KAGT,IAAMyF,EAASrF,UAAgB,CAC7B+E,EAAGnF,EAD0B,QAE7BoF,EAAGpF,EAASqF,SAGR4D,EAAOV,EAduC,wBAkB9CW,EAASD,QAAaV,EAA5B,YACMY,EAASF,SAAcV,EAnBuB,aA2BpD,MAAO,CAAC9C,OAAD,EAAS2D,aALK,CACnBjE,GAAIM,IAAWwD,EAAXxD,KAAuB8C,EAAxB,YADgB,EAEnBnD,GAAIK,IAAWwD,EAAXxD,IAAsB8C,EAAvB,WAAgDY,IC0DEE,CAAkBjJ,EAAhE,GAAqF,CAC1FkJ,SAD0F,EAE1Ff,iB,u0BChHN,IAAMzB,EAAkB,CAEtBtC,OAFsB,KAItB+E,YAJsB,KAKtBC,kBALsB,GAOtBvJ,QAPsB,EAUtBwJ,YAVsB,OAWtBC,SAAU,GAOSC,E,WACnB,qBAA0C,IAA9BrF,MAAU,WAAoB,IAAdD,MAAU,IACpCnF,KAAKmF,QAAUE,mBAAf,GACArF,KAAKsF,OAAS,IAAd,IAEAtF,KAAK0K,cAAgB1K,KAAK0K,cAAclF,KAAxCxF,MACAA,KAAK2K,cAAgB3K,KAAK2K,cAAcnF,KAAxCxF,MAEAA,KAAK4K,WAPmC,OAUjCtF,EAViC,SAWxC,GACEtF,KAAK6K,GAAGvF,G,2BAIZsF,uBAAqB,IAAD,OAMlB,GALI5K,KAAJ,SAEEA,KAAK4F,UAEP5F,KAAKoF,QAAL,EACA,GANkB,IAUXD,EAVW,aAWZ2F,EAAe3F,EAArB,QAqBA,IAAK,IAAL,KAnBAnF,KAAK+K,QAAU,IAAID,EAAa1F,EAAS,CACvCmF,YAAapF,EAD0B,YAEvCkF,YAAalF,eAAuBnE,IAFvB,kBAGOhB,KAHtB,eAKKmF,EAAL,aAGEE,wBAA+C,SAAA2F,GAC7C,IAAMC,EAAa,cAAnB,GACA,GACE3J,cAAwC,SAAA4J,GACtCD,yBAOqB9F,EAA7B,kBAAwD,CACtD,IAAM8F,EAAajL,KAAK+K,QAAQ/B,IAAhC,GACA,KAAgB,CACd,IAAMmC,EAAmBhG,oBADX,UAGPgG,EAAP,OACAF,UAOJjL,KAAKoL,WAAa,IAAI,EAAJ,EAAwBpL,KAAxB,cAA4C,CAC5DoB,QAAQ,IAEVpB,KAAKqL,UAAY,IAAI1E,EAAUvB,EAASpF,KAAvB,cAA2C,CAC1DoB,QAAQ,IAEVpB,KAAKsL,SAAW,IAAIjE,EAASjC,EAASpF,KAAtB,cAA0C,CACxDoB,QADwD,EAExDoJ,SAAUrF,EAAQqF,WAEpBxK,KAAKuL,iBAAmB,IAAI7D,EAAiBtC,EAASpF,KAA9B,cAAkD,CACxEoB,QAAQ,IAIV,cAA2CpB,KAA3C,uBAAwD,CAAC,IAAD,UAA5CwL,EAA4C,KAAhCC,EAAgC,KACjDA,EAAL,YAEEzL,KAAK0L,kBAAkBD,EAAvB,mBACAzL,KAAK+K,QAAQF,GAAGW,EAAYC,EAA5B,iB,EAMN7F,mBACM5F,KAAJ,UAGEA,KAAKoL,WAAWxF,UAChB5F,KAAKqL,UAAUzF,UACf5F,KAAKsL,SAAS1F,UACd5F,KAAKuL,iBAAiB3F,UACtB5F,KAAK+K,QAAQnF,UAEb5F,KAAKoL,WAAL,KACApL,KAAKqL,UAAL,KACArL,KAAKsL,SAAL,KACAtL,KAAKuL,iBAAL,KACAvL,KAAK+K,QAAL,KACA/K,KAAKoF,QAAL,O,EAKJyF,mBACE7K,KAAK2L,iBAAiBzK,EAAM,EAA5B,O,EAIFoH,qBACEtI,KAAK2L,iBAAiBzK,EAAM,EAA5B,O,EAMF0K,sBACE5L,KAAK2L,iBAAiBzK,EAAM,EAA5B,U,EAQF2K,kBACE7L,KAAK8L,oBAAoB5K,EAAM,I,EAMjCwK,gCAAkC,IACzBX,EADwB,aAE/B,MAGA,IAAME,EAAaF,MAAnB,GACA,GAAIE,GAAcA,mBAAlB,EAAyD,CACvDA,MAAe,CAAC7J,OAAQ2K,IAExB,IAAMC,EAAsBnK,EAA5B,GACImK,IAAwBhM,KAAKmF,QAAjC,aAGE6G,WAA4B,SAAAd,GAC1B,IAAMe,EAAkBlB,MAAxB,GACA,GAEEkB,oBAQAhB,yBAGAgB,2BAKRjM,KAAKoL,WAAWvF,gBAAgBmF,EAAK,GACrChL,KAAKqL,UAAUxF,gBAAgBmF,EAAK,GACpChL,KAAKsL,SAASzF,gBAAgBmF,EAAK,GACnChL,KAAKuL,iBAAiB1F,gBAAgBmF,EAAK,K,EAM7CW,qCACE,oBAAWzK,EAAX,CADoD,IAU7C6J,EAV6C,aAUpCzF,EAVoC,YAY9CkG,EAAahH,MAAnB,EAEIiH,EAAiBnG,MAArB,GACA,IACEmG,EAAiB,IAAI,EAArBA,MACAnG,QAFmB,GAInBmG,iBAAgCnJ,MAJb,EAMnB,GACEyI,OAAuBU,EAAvBV,cAGJU,iBACKA,EAAL,WACEzL,KAAK0L,kBAAkBD,EAAvB,wBAvBA,IAAK,IAAL,KAFAlD,EAD6B,EAG7B,EACEvI,KAAK2L,iBAAiBO,EAAWhL,EAAjC,W,EA6BN4K,kCACE,oBAAW5K,EAAX,CADkC,IAS3BoE,EAT2B,YAW5BkG,EAAahH,MAAnB,EAEMiH,EAAiBnG,MAAvB,GAEA,OAIAmG,cAEIA,EAAJ,WAA8B,CAI5B,IAJ6B,IAI7B,EAHOU,EAAkBV,EADG,eAGxBW,GAAJ,EACA,IAAiB9G,EAAjB,yBAAkC,CAAC,IAAxB+G,EAAuB,QAChC,GAAIA,uBAAyCA,EAA7C,UAA2D,CACzDD,KACA,OAGJ,GACEpM,KAAK0L,kBAAkBS,GAAe,SA7BxC,IAAK,IAAL,OACEnM,KAAK8L,oBAAoBI,EAAWhL,EAApC,K,EAwCNwJ,0BAAsB,IACb5J,EAAYI,EADA,SAEboL,EAAQxK,EAAoBhB,EAAlC,MACA,GAEEd,KAAK+K,QAAQwB,KAAKD,EAAM,I,EAQ5B3B,0BAEE3K,KAAK+K,QAAQwB,KAAKrL,EAAlB,S,KClTSsL,G,UAAS,CAAC,QAAD,8YAAf,UAuCMC,EAAkB,CAC7BhI,OAD6B,EAE7B9C,WAF6B,EAG7BgB,YAH6B,EAI7BC,WAJ6B,EAK7BC,UAL6B,EAM7BE,aAN6B,EAO7BC,YAP6B,EAQ7BC,WAR6B,EAS7BU,UAT6B,EAU7BC,SAV6B,EAW7BK,QAX6B,EAY7ByI,OAAO,GC5CYC,E,YACnB,cAAoB,IAAD,SACjB,wBAEA,QAAe,2BAAf,IACA,gBAAqB,iCAArB,IACA,kBAAuB,mCAAvB,IACA,eAAoB,gCAApB,IACA,kBAAuB,mCAAvB,IAEA,oBACAH,WAAe,SAAAN,GACTO,EAAJ,KACE,oBAAiC,EAAjC,iBAIJ,gBAAqB,IAAI,EAAJ,KAAuB,CAC1CnH,OAAQ,EAAKsH,iBAGf,QAAa,CACXtH,OADW,GAEXH,QAASsH,GAtBM,E,4CA0BnBI,oBACE7M,KAAK8M,cAAclC,WAAWmC,I,EAGhCC,0BACE,GACEhN,KAAK8M,cAAcjC,GAAG7K,KAAtB,kBAEFA,KAAKiN,QAAL,G,EAGFC,4BAAsB,IAAD,IACKC,EADL,OACZnC,EADY,OACNoC,EADM,UAEnB,GACEpN,KAAK4M,eAAe5B,GAAQhL,KAA5B,aACAA,KAAK8M,cAAcjC,GAAGG,EAAMhL,KAA5B,cACAA,KAAK8M,cAAcjC,GAAGG,EAAMhL,KAA5B,aAA+CA,KAA/C,kBAEOA,KAAA,eAAP,GACAA,KAAK8M,cAAcjB,IAAIb,EAAMhL,KAA7B,cACAA,KAAK8M,cAAcjB,IAAIb,EAAMhL,KAA7B,aAAgDA,KAAhD,UAEFA,KAAKqN,SAAS,CACZlI,QAASE,iBAAkBrF,KAAKsN,MAAvBjI,4B,EAIbkI,yBACEJ,mBACAA,oBACA,IAAM7H,EAAStF,KAAKsN,MAAMhI,OAAOkI,MAAM,EAAvC,IACAlI,aACAtF,KAAKqN,SAAS,CAAC/H,Y,EAGjBmI,4BAA4B,IACnBtI,EAAWnF,KADO,cAEnB0N,EAAE,SAAR,EAEA,OACE,yBAAKjG,IAAKyE,GACR,2BACEwB,GADF,EAEEpH,KAFF,WAGE0E,KAHF,EAIEoC,QAASjI,OAJX,EAKEwI,SAAU3N,KAAKkN,kBAEjB,2BAAOU,QAASF,GATpB,K,EAcFG,2BACE,OACE,yBAAKpG,IAAKqG,GACR,0BAAMrG,IAAI,QAAQ0F,EADpB,MAEE,0BAAM1F,IAAI,YACP0F,mBACOA,yBADPA,QACyCA,yBADzCA,OAHL,IAOE,0BAAM1F,IAAI,UACP0F,OACEA,cADFA,eAEEA,gBAFFA,iBAGEA,eAXP,gBAaE,0BAAM1F,IAAI,UAAU0F,SAdxB,M,EAmBFY,kBAAU,IACDzI,EAAUtF,KADV,aAGP,OACE,yBAAK0N,GAAG,aACN,yBAAKA,GAAL,aAAqBX,IAAK/M,KAAK6M,SAC7B,yBAAKa,GAAL,UAAkBX,IAAK/M,KAAKgN,iBAG9B,yBAAKU,GAAG,QAAQpI,MAAWtF,KAL7B,eAOE,yBAAK0N,GAAG,WAAWlB,MAAWxM,KARlC,oB,GAvG6BgO,aAqH1B,SAASC,EAAYC,GAC1BH,iBAAO,oBAAD,MAANA,K,qBCjJF,OAKA,SAAWhI,EAAQoI,EAAUC,EAAYC,GACvC,aAEA,IAkGIC,EAlGAC,EAAkB,CAAC,GAAI,SAAU,MAAO,KAAM,KAAM,KACpDC,EAAeL,EAASM,cAAc,OAEtCC,EAAQtI,KAAKsI,MACbC,EAAMvI,KAAKuI,IACXC,EAAMC,KAAKD,IASf,SAASE,EAAkBC,EAAIC,EAASC,GACtC,OAAOC,WAAWC,EAAOJ,EAAIE,GAAUD,GAazC,SAASI,EAAeC,EAAKN,EAAIE,GAC/B,QAAIK,MAAMC,QAAQF,KAChBG,EAAKH,EAAKJ,EAAQF,GAAKE,IAChB,GAaX,SAASO,EAAKC,EAAKC,EAAUT,GAC3B,IAAI/O,EAEJ,GAAKuP,EAIL,GAAIA,EAAIhK,QACNgK,EAAIhK,QAAQiK,EAAUT,QACjB,QAxDX,IAwDeQ,EAAIE,OAGb,IAFAzP,EAAI,EAEGA,EAAIuP,EAAIE,QACbD,EAASE,KAAKX,EAASQ,EAAIvP,GAAIA,EAAGuP,GAClCvP,SAGF,IAAKA,KAAKuP,EACRA,EAAII,eAAe3P,IAAMwP,EAASE,KAAKX,EAASQ,EAAIvP,GAAIA,EAAGuP,GAajE,SAASK,EAAUC,EAAQ/E,EAAMgF,GAC/B,IAAIC,EAAqB,sBAAwBjF,EAAO,KAAOgF,EAAU,SACzE,OAAO,WACL,IAAI3P,EAAI,IAAI6P,MAAM,mBACdC,EAAQ9P,GAAKA,EAAE8P,MAAQ9P,EAAE8P,MAAMC,QAAQ,kBAAmB,IAAIA,QAAQ,cAAe,IAAIA,QAAQ,6BAA8B,kBAAoB,sBACnJC,EAAMtK,EAAOuK,UAAYvK,EAAOuK,QAAQC,MAAQxK,EAAOuK,QAAQD,KAMnE,OAJIA,GACFA,EAAIT,KAAK7J,EAAOuK,QAASL,EAAoBE,GAGxCJ,EAAOS,MAAMxQ,KAAMyQ,YAe5BnC,EAD2B,mBAAlBjJ,OAAOiJ,OACP,SAAgB7H,GACvB,GAAIA,QACF,MAAM,IAAIiK,UAAU,8CAKtB,IAFA,IAAIC,EAAStL,OAAOoB,GAEXqH,EAAQ,EAAGA,EAAQ2C,UAAUd,OAAQ7B,IAAS,CACrD,IAAI8C,EAASH,UAAU3C,GAEvB,GAAI8C,QACF,IAAK,IAAIC,KAAWD,EACdA,EAAOf,eAAegB,KACxBF,EAAOE,GAAWD,EAAOC,IAMjC,OAAOF,GAGAtL,OAAOiJ,OAYlB,IAAIwC,EAAShB,GAAU,SAAgBiB,EAAMC,EAAKC,GAIhD,IAHA,IAAIC,EAAO7L,OAAO6L,KAAKF,GACnB9Q,EAAI,EAEDA,EAAIgR,EAAKvB,UACTsB,GAASA,QA/IpB,IA+I6BF,EAAKG,EAAKhR,OAC/B6Q,EAAKG,EAAKhR,IAAM8Q,EAAIE,EAAKhR,KAG3BA,IAGF,OAAO6Q,IACN,SAAU,iBASTE,EAAQnB,GAAU,SAAeiB,EAAMC,GACzC,OAAOF,EAAOC,EAAMC,GAAK,KACxB,QAAS,iBAQZ,SAASG,EAAQC,EAAOC,EAAMC,GAC5B,IACIC,EADAC,EAAQH,EAAKI,WAEjBF,EAASH,EAAMK,UAAYpM,OAAOqM,OAAOF,IAClCG,YAAcP,EACrBG,EAAOK,OAASJ,EAEZF,GACFhD,EAAOiD,EAAQD,GAWnB,SAASnC,EAAOJ,EAAIE,GAClB,OAAO,WACL,OAAOF,EAAGyB,MAAMvB,EAASwB,YAY7B,SAASoB,EAASC,EAAKC,GACrB,MAvMkB,mBAuMPD,EACFA,EAAItB,MAAMuB,GAAOA,EAAK,SA7MnC,EA6MgEA,GAGrDD,EAUT,SAASE,EAAYC,EAAMC,GACzB,YA3NJ,IA2NWD,EAAqBC,EAAOD,EAUrC,SAASE,EAAkB1L,EAAQ2L,EAAO1J,GACxC8G,EAAK6C,EAASD,IAAQ,SAAU9L,GAC9BG,EAAO6L,iBAAiBhM,EAAMoC,GAAS,MAW3C,SAAS6J,EAAqB9L,EAAQ2L,EAAO1J,GAC3C8G,EAAK6C,EAASD,IAAQ,SAAU9L,GAC9BG,EAAOkB,oBAAoBrB,EAAMoC,GAAS,MAY9C,SAAS8J,EAAUC,EAAMC,GACvB,KAAOD,GAAM,CACX,GAAIA,GAAQC,EACV,OAAO,EAGTD,EAAOA,EAAKE,WAGd,OAAO,EAUT,SAASC,EAAMC,EAAKC,GAClB,OAAOD,EAAIE,QAAQD,IAAS,EAS9B,SAAST,EAASQ,GAChB,OAAOA,EAAIG,OAAOC,MAAM,QAW1B,SAASC,EAAQlC,EAAK8B,EAAMK,GAC1B,GAAInC,EAAI+B,UAAYI,EAClB,OAAOnC,EAAI+B,QAAQD,GAInB,IAFA,IAAI5S,EAAI,EAEDA,EAAI8Q,EAAIrB,QAAQ,CACrB,GAAIwD,GAAanC,EAAI9Q,GAAGiT,IAAcL,IAASK,GAAanC,EAAI9Q,KAAO4S,EACrE,OAAO5S,EAGTA,IAGF,OAAQ,EAUZ,SAASkT,EAAQ3D,GACf,OAAOH,MAAMmC,UAAUjE,MAAMoC,KAAKH,EAAK,GAWzC,SAAS4D,EAAYrC,EAAKvJ,EAAK6L,GAK7B,IAJA,IAAIC,EAAU,GACVC,EAAS,GACTtT,EAAI,EAEDA,EAAI8Q,EAAIrB,QAAQ,CACrB,IAAImC,EAAMrK,EAAMuJ,EAAI9Q,GAAGuH,GAAOuJ,EAAI9Q,GAE9BgT,EAAQM,EAAQ1B,GAAO,GACzByB,EAAQE,KAAKzC,EAAI9Q,IAGnBsT,EAAOtT,GAAK4R,EACZ5R,IAaF,OAVIoT,IAIAC,EAHG9L,EAGO8L,EAAQD,MAAK,SAAyBI,EAAGC,GACjD,OAAOD,EAAEjM,GAAOkM,EAAElM,MAHV8L,EAAQD,QAQfC,EAUT,SAASK,EAASnE,EAAKoE,GAKrB,IAJA,IAAIC,EAAQC,EACRC,EAAYH,EAAS,GAAGI,cAAgBJ,EAASrG,MAAM,GACvDtN,EAAI,EAEDA,EAAIqO,EAAgBoB,QAAQ,CAIjC,IAFAoE,GADAD,EAASvF,EAAgBrO,IACT4T,EAASE,EAAYH,KAEzBpE,EACV,OAAOsE,EAGT7T,KAWJ,IAAIgU,EAAY,EAYhB,SAASC,EAAoB/O,GAC3B,IAAIgP,EAAMhP,EAAQiP,eAAiBjP,EACnC,OAAOgP,EAAIE,aAAeF,EAAIG,cAAgBxO,EAGhD,IACIyO,EAAiB,iBAAkBzO,EACnC0O,OA5ZN,IA4Z+Bb,EAAS7N,EAAQ,gBAC1C2O,EAAqBF,GAHN,wCAGoCG,KAAKC,UAAU5P,WAkBlE6P,EAAW,CAAC,IAAK,KACjBC,EAAkB,CAAC,UAAW,WASlC,SAASC,EAAMhK,EAASrK,GACtB,IAAIsU,EAAOhV,KACXA,KAAK+K,QAAUA,EACf/K,KAAKU,SAAWA,EAChBV,KAAKoF,QAAU2F,EAAQ3F,QACvBpF,KAAKyG,OAASsE,EAAQ5F,QAAQ8P,YAG9BjV,KAAKkV,WAAa,SAAUpV,GACtB+R,EAAS9G,EAAQ5F,QAAQ/D,OAAQ,CAAC2J,KACpCiK,EAAKtM,QAAQ5I,IAIjBE,KAAKmV,OA6DP,SAASC,EAAarK,EAASvK,EAAW6U,GACxC,IAAIC,EAAcD,EAAM1U,SAASgP,OAC7B4F,EAAqBF,EAAMzU,gBAAgB+O,OAC3C6F,EApGY,EAoGFhV,GAA2B8U,EAAcC,GAAuB,EAC1EE,EAAsB,GAAZjV,GAA0C8U,EAAcC,GAAuB,EAC7FF,EAAMG,UAAYA,EAClBH,EAAMI,UAAYA,EAEdD,IACFzK,EAAQ2K,QAAU,IAKpBL,EAAM7U,UAAYA,EAepB,SAA0BuK,EAASsK,GACjC,IAAIK,EAAU3K,EAAQ2K,QAClB/U,EAAW0U,EAAM1U,SACjBgV,EAAiBhV,EAASgP,OAEzB+F,EAAQE,aACXF,EAAQE,WAAaC,EAAqBR,IAIxCM,EAAiB,IAAMD,EAAQI,cACjCJ,EAAQI,cAAgBD,EAAqBR,GACjB,IAAnBM,IACTD,EAAQI,eAAgB,GAG1B,IAAIF,EAAaF,EAAQE,WACrBE,EAAgBJ,EAAQI,cACxB5L,EAAe4L,EAAgBA,EAAcvP,OAASqP,EAAWrP,OACjEA,EAAS8O,EAAM9O,OAASwP,EAAUpV,GACtC0U,EAAMW,UAAYpH,IAClByG,EAAMY,UAAYZ,EAAMW,UAAYJ,EAAWI,UAC/CX,EAAMa,MAAQC,EAASjM,EAAc3D,GACrC8O,EAAMe,SAAWC,EAAYnM,EAAc3D,GAqB7C,SAAwBmP,EAASL,GAC/B,IAAI9O,EAAS8O,EAAM9O,OACf+P,EAASZ,EAAQa,aAAe,GAChCC,EAAYd,EAAQc,WAAa,GACjCC,EAAYf,EAAQe,WAAa,GA9KrB,IAgLZpB,EAAM7U,WA9KI,IA8KyBiW,EAAUjW,YAC/CgW,EAAYd,EAAQc,UAAY,CAC9BvQ,EAAGwQ,EAAUC,QAAU,EACvBxQ,EAAGuQ,EAAUE,QAAU,GAEzBL,EAASZ,EAAQa,YAAc,CAC7BtQ,EAAGM,EAAON,EACVC,EAAGK,EAAOL,IAIdmP,EAAMqB,OAASF,EAAUvQ,GAAKM,EAAON,EAAIqQ,EAAOrQ,GAChDoP,EAAMsB,OAASH,EAAUtQ,GAAKK,EAAOL,EAAIoQ,EAAOpQ,GAtChD0Q,CAAelB,EAASL,GACxBA,EAAMwB,gBAAkBC,EAAazB,EAAMqB,OAAQrB,EAAMsB,QACzD,IAAII,EAAkBC,EAAY3B,EAAMY,UAAWZ,EAAMqB,OAAQrB,EAAMsB,QACvEtB,EAAM4B,iBAAmBF,EAAgB9Q,EACzCoP,EAAM6B,iBAAmBH,EAAgB7Q,EACzCmP,EAAM0B,gBAAkBpI,EAAIoI,EAAgB9Q,GAAK0I,EAAIoI,EAAgB7Q,GAAK6Q,EAAgB9Q,EAAI8Q,EAAgB7Q,EAC9GmP,EAAM8B,MAAQrB,GA8NEsB,EA9NuBtB,EAAcnV,SA8N9B0W,EA9NwC1W,EA+NxD0V,EAAYgB,EAAI,GAAIA,EAAI,GAAIvC,GAAmBuB,EAAYe,EAAM,GAAIA,EAAM,GAAItC,IA/NX,EAC3EO,EAAMiC,SAAWxB,EAiNnB,SAAqBsB,EAAOC,GAC1B,OAAOlB,EAASkB,EAAI,GAAIA,EAAI,GAAIvC,GAAmBqB,EAASiB,EAAM,GAAIA,EAAM,GAAItC,GAlN/CyC,CAAYzB,EAAcnV,SAAUA,GAAY,EACjF0U,EAAMmC,YAAe9B,EAAQe,UAAoCpB,EAAM1U,SAASgP,OAAS+F,EAAQe,UAAUe,YAAcnC,EAAM1U,SAASgP,OAAS+F,EAAQe,UAAUe,YAA1HnC,EAAM1U,SAASgP,OAuC1D,SAAkC+F,EAASL,GACzC,IAEIoC,EACAC,EACAC,EACAC,EALAC,EAAOnC,EAAQoC,cAAgBzC,EAC/BY,EAAYZ,EAAMW,UAAY6B,EAAK7B,UAMvC,GA1MiB,GA0MbX,EAAM7U,YAA8ByV,EA9MnB,SAlazB,IAgnB4E4B,EAAKJ,UAAyB,CACpG,IAAIf,EAASrB,EAAMqB,OAASmB,EAAKnB,OAC7BC,EAAStB,EAAMsB,OAASkB,EAAKlB,OAC7BoB,EAAIf,EAAYf,EAAWS,EAAQC,GACvCe,EAAYK,EAAE9R,EACd0R,EAAYI,EAAE7R,EACduR,EAAW9I,EAAIoJ,EAAE9R,GAAK0I,EAAIoJ,EAAE7R,GAAK6R,EAAE9R,EAAI8R,EAAE7R,EACzC0R,EAAYd,EAAaJ,EAAQC,GACjCjB,EAAQoC,aAAezC,OAGvBoC,EAAWI,EAAKJ,SAChBC,EAAYG,EAAKH,UACjBC,EAAYE,EAAKF,UACjBC,EAAYC,EAAKD,UAGnBvC,EAAMoC,SAAWA,EACjBpC,EAAMqC,UAAYA,EAClBrC,EAAMsC,UAAYA,EAClBtC,EAAMuC,UAAYA,EAlElBI,CAAyBtC,EAASL,GA2NpC,IAAkB+B,EAAOC,EAzNvB,IAAI5Q,EAASsE,EAAQ3F,QAEjBoN,EAAU6C,EAAMvU,SAAS2F,OAAQA,KACnCA,EAAS4O,EAAMvU,SAAS2F,QAG1B4O,EAAM5O,OAASA,EAtDfwR,CAAiBlN,EAASsK,GAE1BtK,EAAQwB,KAAK,eAAgB8I,GAC7BtK,EAAQmN,UAAU7C,GAClBtK,EAAQ2K,QAAQe,UAAYpB,EAqH9B,SAASQ,EAAqBR,GAM5B,IAHA,IAAI1U,EAAW,GACXT,EAAI,EAEDA,EAAImV,EAAM1U,SAASgP,QACxBhP,EAAST,GAAK,CACZiY,QAASzJ,EAAM2G,EAAM1U,SAAST,GAAGiY,SACjChS,QAASuI,EAAM2G,EAAM1U,SAAST,GAAGiG,UAEnCjG,IAGF,MAAO,CACL8V,UAAWpH,IACXjO,SAAUA,EACV4F,OAAQwP,EAAUpV,GAClB+V,OAAQrB,EAAMqB,OACdC,OAAQtB,EAAMsB,QAUlB,SAASZ,EAAUpV,GACjB,IAAIgV,EAAiBhV,EAASgP,OAE9B,GAAuB,IAAnBgG,EACF,MAAO,CACL1P,EAAGyI,EAAM/N,EAAS,GAAGwX,SACrBjS,EAAGwI,EAAM/N,EAAS,GAAGwF,UAQzB,IAJA,IAAIF,EAAI,EACJC,EAAI,EACJhG,EAAI,EAEDA,EAAIyV,GACT1P,GAAKtF,EAAST,GAAGiY,QACjBjS,GAAKvF,EAAST,GAAGiG,QACjBjG,IAGF,MAAO,CACL+F,EAAGyI,EAAMzI,EAAI0P,GACbzP,EAAGwI,EAAMxI,EAAIyP,IAYjB,SAASqB,EAAYf,EAAWhQ,EAAGC,GACjC,MAAO,CACLD,EAAGA,EAAIgQ,GAAa,EACpB/P,EAAGA,EAAI+P,GAAa,GAWxB,SAASa,EAAa7Q,EAAGC,GACvB,OAAID,IAAMC,EApTS,EAwTfyI,EAAI1I,IAAM0I,EAAIzI,GACTD,EAAI,EAxTM,EACC,EA0TbC,EAAI,EAzTM,EACE,GAmUrB,SAASmQ,EAAY+B,EAAIC,EAAIC,GACtBA,IACHA,EAAQzD,GAGV,IAAI5O,EAAIoS,EAAGC,EAAM,IAAMF,EAAGE,EAAM,IAC5BpS,EAAImS,EAAGC,EAAM,IAAMF,EAAGE,EAAM,IAChC,OAAOlS,KAAKmS,KAAKtS,EAAIA,EAAIC,EAAIA,GAW/B,SAASiQ,EAASiC,EAAIC,EAAIC,GACnBA,IACHA,EAAQzD,GAGV,IAAI5O,EAAIoS,EAAGC,EAAM,IAAMF,EAAGE,EAAM,IAC5BpS,EAAImS,EAAGC,EAAM,IAAMF,EAAGE,EAAM,IAChC,OAA0B,IAAnBlS,KAAKoS,MAAMtS,EAAGD,GAAWG,KAAKqS,GA7TvC1D,EAAMtD,UAAY,CAKhB/I,QAAS,aAKTyM,KAAM,WACJnV,KAAK0Y,MAAQvG,EAAkBnS,KAAKoF,QAASpF,KAAK0Y,KAAM1Y,KAAKkV,YAC7DlV,KAAK2Y,UAAYxG,EAAkBnS,KAAKyG,OAAQzG,KAAK2Y,SAAU3Y,KAAKkV,YACpElV,KAAK4Y,OAASzG,EAAkBgC,EAAoBnU,KAAKoF,SAAUpF,KAAK4Y,MAAO5Y,KAAKkV,aAMtFtP,QAAS,WACP5F,KAAK0Y,MAAQnG,EAAqBvS,KAAKoF,QAASpF,KAAK0Y,KAAM1Y,KAAKkV,YAChElV,KAAK2Y,UAAYpG,EAAqBvS,KAAKyG,OAAQzG,KAAK2Y,SAAU3Y,KAAKkV,YACvElV,KAAK4Y,OAASrG,EAAqB4B,EAAoBnU,KAAKoF,SAAUpF,KAAK4Y,MAAO5Y,KAAKkV,cAiU3F,IAAI1V,EAAkB,CACpBC,UA/XgB,EAgYhBC,UA/Xe,EAgYfC,QA/Xc,GAyYhB,SAASY,IACPP,KAAK0Y,KAToB,YAUzB1Y,KAAK4Y,MATmB,oBAUxB5Y,KAAKS,SAAU,EAEfsU,EAAMvE,MAAMxQ,KAAMyQ,WAGpBU,EAAQ5Q,EAAYwU,EAAO,CAKzBrM,QAAS,SAAmB5I,GAC1B,IAAIU,EAAYhB,EAAgBM,EAAGwG,MAzZrB,EA2ZV9F,GAAyC,IAAdV,EAAGyJ,SAChCvJ,KAAKS,SAAU,GA3ZJ,EA8ZTD,GAAuC,IAAbV,EAAG0J,QAC/BhJ,EA9ZU,GAkaPR,KAAKS,UAlaE,EAsaRD,IACFR,KAAKS,SAAU,GAGjBT,KAAKU,SAASV,KAAK+K,QAASvK,EAAW,CACrCG,SAAU,CAACb,GACXc,gBAAiB,CAACd,GAClBe,YAlbiB,QAmbjBC,SAAUhB,QAIhB,IAAI+Y,EAAoB,CACtB9W,YArbgB,EAsbhBC,YArbe,EAsbfC,UArbc,EAsbd6W,cArbiB,EAsbjBC,WAtbiB,GAybfC,EAAyB,CAC3BC,EAlcqB,QAmcrBC,EAlcmB,MAmcnBC,EAlcqB,QAmcrBC,EAlcsB,UAqcpBC,EAAyB,cACzBC,EAAwB,sCAa5B,SAASha,KACPU,KAAK0Y,KAAOW,EACZrZ,KAAK4Y,MAAQU,EACbvE,EAAMvE,MAAMxQ,KAAMyQ,WAClBzQ,KAAKD,MAAQC,KAAK+K,QAAQ2K,QAAQ6D,cAAgB,GAfhDxT,EAAOyT,iBAAmBzT,EAAO0T,eACnCJ,EAAyB,gBACzBC,EAAwB,6CAgB1BnI,EAAQ7R,GAAmByV,EAAO,CAKhCrM,QAAS,SAAmB5I,GAC1B,IAAIC,EAAQC,KAAKD,MACb2Z,GAAgB,EAChBC,EAAsB7Z,EAAGwG,KAAKsT,cAAcxJ,QAAQ,KAAM,IAC1D5P,EAAYqY,EAAkBc,GAC9B9Y,EAAcmY,EAAuBlZ,EAAGe,cAAgBf,EAAGe,YAC3DgZ,EAxee,SAweLhZ,EAEViZ,EAAa5G,EAAQnT,EAAOD,EAAGia,UAAW,aArehC,EAueVvZ,IAA0C,IAAdV,EAAGyJ,QAAgBsQ,GAC7CC,EAAa,IACf/Z,EAAM0T,KAAK3T,GACXga,EAAa/Z,EAAM4P,OAAS,GAET,GAAZnP,IACTkZ,GAAgB,GAIdI,EAAa,IAKjB/Z,EAAM+Z,GAAcha,EACpBE,KAAKU,SAASV,KAAK+K,QAASvK,EAAW,CACrCG,SAAUZ,EACVa,gBAAiB,CAACd,GAClBe,YAAaA,EACbC,SAAUhB,IAGR4Z,GAEF3Z,EAAMia,OAAOF,EAAY,OAI/B,IAAIG,GAAyB,CAC3B/X,WArgBgB,EAsgBhBC,UArgBe,EAsgBfC,SArgBc,EAsgBd8X,YArgBiB,GA+gBnB,SAASC,KACPna,KAAK2Y,SAT0B,aAU/B3Y,KAAK4Y,MAT0B,4CAU/B5Y,KAAKoa,SAAU,EACfrF,EAAMvE,MAAMxQ,KAAMyQ,WAoCpB,SAAS4J,GAAuBva,EAAIwG,GAClC,IAAIgU,EAAMlH,EAAQtT,EAAGya,SACjBC,EAAUpH,EAAQtT,EAAG2a,gBAMzB,OAJW,GAAPnU,IACFgU,EAAMjH,EAAYiH,EAAII,OAAOF,GAAU,cAAc,IAGhD,CAACF,EAAKE,GAzCfrJ,EAAQgJ,GAAkBpF,EAAO,CAC/BrM,QAAS,SAAmB5I,GAC1B,IAAIwG,EAAO2T,GAAuBna,EAAGwG,MAMrC,GAjiBc,IA6hBVA,IACFtG,KAAKoa,SAAU,GAGZpa,KAAKoa,QAAV,CAIA,IAAIG,EAAUF,GAAuBzK,KAAK5P,KAAMF,EAAIwG,GAEzC,GAAPA,GAAqCiU,EAAQ,GAAG5K,OAAS4K,EAAQ,GAAG5K,QAAW,IACjF3P,KAAKoa,SAAU,GAGjBpa,KAAKU,SAASV,KAAK+K,QAASzE,EAAM,CAChC3F,SAAU4Z,EAAQ,GAClB3Z,gBAAiB2Z,EAAQ,GACzB1Z,YAnjBiB,QAojBjBC,SAAUhB,QAsBhB,IAAI6a,GAAkB,CACpBzY,WAtkBgB,EAukBhBC,UAtkBe,EAukBfC,SAtkBc,EAukBd8X,YAtkBiB,GA+kBnB,SAASU,KACP5a,KAAK2Y,SARmB,4CASxB3Y,KAAK6a,UAAY,GACjB9F,EAAMvE,MAAMxQ,KAAMyQ,WA2BpB,SAASqK,GAAWhb,EAAIwG,GACtB,IAAIyU,EAAa3H,EAAQtT,EAAGya,SACxBM,EAAY7a,KAAK6a,UAErB,GAAW,EAAPvU,GAA2D,IAAtByU,EAAWpL,OAElD,OADAkL,EAAUE,EAAW,GAAGC,aAAc,EAC/B,CAACD,EAAYA,GAGtB,IAAI7a,EACA+a,EACAR,EAAiBrH,EAAQtT,EAAG2a,gBAC5BS,EAAuB,GACvBzU,EAASzG,KAAKyG,OAMlB,GAJAwU,EAAgBF,EAAWI,QAAO,SAAUC,GAC1C,OAAO5I,EAAU4I,EAAM3U,OAAQA,MAhoBjB,IAmoBZH,EAGF,IAFApG,EAAI,EAEGA,EAAI+a,EAActL,QACvBkL,EAAUI,EAAc/a,GAAG8a,aAAc,EACzC9a,IAOJ,IAFAA,EAAI,EAEGA,EAAIua,EAAe9K,QACpBkL,EAAUJ,EAAeva,GAAG8a,aAC9BE,EAAqBzH,KAAKgH,EAAeva,IAIhC,GAAPoG,UACKuU,EAAUJ,EAAeva,GAAG8a,YAGrC9a,IAGF,OAAKgb,EAAqBvL,OAInB,CACP0D,EAAY4H,EAAcP,OAAOQ,GAAuB,cAAc,GAAOA,QAL7E,EApEF/J,EAAQyJ,GAAY7F,EAAO,CACzBrM,QAAS,SAAoB5I,GAC3B,IAAIwG,EAAOqU,GAAgB7a,EAAGwG,MAC1BiU,EAAUO,GAAWlL,KAAK5P,KAAMF,EAAIwG,GAEnCiU,GAILva,KAAKU,SAASV,KAAK+K,QAASzE,EAAM,CAChC3F,SAAU4Z,EAAQ,GAClB3Z,gBAAiB2Z,EAAQ,GACzB1Z,YAzmBiB,QA0mBjBC,SAAUhB,OA4EhB,SAASub,KACPtG,EAAMvE,MAAMxQ,KAAMyQ,WAClB,IAAI/H,EAAUyG,EAAOnP,KAAK0I,QAAS1I,MACnCA,KAAKob,MAAQ,IAAIR,GAAW5a,KAAK+K,QAASrC,GAC1C1I,KAAKsb,MAAQ,IAAI/a,EAAWP,KAAK+K,QAASrC,GAC1C1I,KAAKub,aAAe,KACpBvb,KAAKwb,YAAc,GAqCrB,SAASC,GAAcjb,EAAWkb,GA5tBhB,EA6tBZlb,GACFR,KAAKub,aAAeG,EAAU9a,gBAAgB,GAAGoa,WACjDW,GAAa/L,KAAK5P,KAAM0b,IACH,GAAZlb,GACTmb,GAAa/L,KAAK5P,KAAM0b,GAI5B,SAASC,GAAaD,GACpB,IAAIN,EAAQM,EAAU9a,gBAAgB,GAEtC,GAAIwa,EAAMJ,aAAehb,KAAKub,aAAc,CAC1C,IAAIK,EAAY,CACd3V,EAAGmV,EAAMjD,QACTjS,EAAGkV,EAAMjV,SAEXnG,KAAKwb,YAAY/H,KAAKmI,GACtB,IAAIC,EAAM7b,KAAKwb,YAUftM,YARsB,WACpB,IAAIhP,EAAI2b,EAAI9I,QAAQ6I,GAEhB1b,GAAK,GACP2b,EAAI7B,OAAO9Z,EAAG,KAtEF,OA8EpB,SAAS4b,GAAiBJ,GAIxB,IAHA,IAAIzV,EAAIyV,EAAU5a,SAASqX,QACvBjS,EAAIwV,EAAU5a,SAASqF,QAElBjG,EAAI,EAAGA,EAAIF,KAAKwb,YAAY7L,OAAQzP,IAAK,CAChD,IAAI6b,EAAI/b,KAAKwb,YAAYtb,GACrB8b,EAAK5V,KAAKuI,IAAI1I,EAAI8V,EAAE9V,GACpBgW,EAAK7V,KAAKuI,IAAIzI,EAAI6V,EAAE7V,GAExB,GAAI8V,GAtFa,IAsFWC,GAtFX,GAuFf,OAAO,EAIX,OAAO,EAhFT9K,EAAQkK,GAAiBtG,EAAO,CAO9BrM,QAAS,SAAoBqC,EAASmR,EAAYC,GAChD,IAAItC,EAvsBe,SAusBLsC,EAAUtb,YACpBub,EAtsBe,SAssBLD,EAAUtb,YAExB,KAAIub,GAAWD,EAAUE,oBAAsBF,EAAUE,mBAAmBC,kBAA5E,CAKA,GAAIzC,EACF4B,GAAc7L,KAAK5P,KAAMkc,EAAYC,QAChC,GAAIC,GAAWN,GAAiBlM,KAAK5P,KAAMmc,GAChD,OAGFnc,KAAKU,SAASqK,EAASmR,EAAYC,KAMrCvW,QAAS,WACP5F,KAAKob,MAAMxV,UACX5F,KAAKsb,MAAM1V,aAqDf,IAAI2W,GAAwB3I,EAASpF,EAAagO,MAAO,eACrDC,QAjrCN,IAirC4BF,GAStBG,GAwIJ,WACE,IAAKD,GACH,OAAO,EAGT,IAAIE,EAAW,GACXC,EAAc7W,EAAO8W,KAAO9W,EAAO8W,IAAIC,SAM3C,MALA,CAAC,OAAQ,eAAgB,QAAS,QAAS,cAAe,QAAQrX,SAAQ,SAAUqM,GAGlF6K,EAAS7K,IAAO8K,GAAc7W,EAAO8W,IAAIC,SAAS,eAAgBhL,MAE7D6K,EApJcI,GASvB,SAASC,GAAYjS,EAASjF,GAC5B9F,KAAK+K,QAAUA,EACf/K,KAAKid,IAAInX,GAGXkX,GAAYvL,UAAY,CAKtBwL,IAAK,SAAanX,GA1BO,WA4BnBA,IACFA,EAAQ9F,KAAKkd,WAGXT,IAAuBzc,KAAK+K,QAAQ3F,QAAQoX,OAASE,GAAiB5W,KACxE9F,KAAK+K,QAAQ3F,QAAQoX,MAAMD,IAAyBzW,GAGtD9F,KAAKmd,QAAUrX,EAAM8T,cAAc5G,QAMrCoK,OAAQ,WACNpd,KAAKid,IAAIjd,KAAK+K,QAAQ5F,QAAQoF,cAOhC2S,QAAS,WACP,IAAIC,EAAU,GAMd,OALA3N,EAAKxP,KAAK+K,QAAQV,aAAa,SAAUY,GACnC4G,EAAS5G,EAAW9F,QAAQ/D,OAAQ,CAAC6J,MACvCkS,EAAUA,EAAQzC,OAAOzP,EAAWoS,sBA4D5C,SAA2BF,GAEzB,GAAIvK,EAAMuK,EAhHY,QAiHpB,MAjHoB,OAoHtB,IAAIG,EAAU1K,EAAMuK,EAnHG,SAoHnBI,EAAU3K,EAAMuK,EAnHG,SAwHvB,GAAIG,GAAWC,EACb,MA3HoB,OA+HtB,GAAID,GAAWC,EACb,OAAOD,EA/Hc,QACA,QAkIvB,GAAI1K,EAAMuK,EAtIoB,gBAuI5B,MAvI4B,eA0I9B,MA3IsB,OAwDbK,CAAkBL,EAAQM,KAAK,OAOxCC,gBAAiB,SAAyBrI,GACxC,IAAIvU,EAAWuU,EAAMvU,SACjB8W,EAAYvC,EAAMwB,gBAEtB,GAAI7W,KAAK+K,QAAQ2K,QAAQiI,UACvB7c,EAAS8c,qBADX,CAKA,IAAIT,EAAUnd,KAAKmd,QACfU,EAAUjL,EAAMuK,EAtEA,UAsEgCT,GAAkC,KAClFa,EAAU3K,EAAMuK,EArEC,WAqEgCT,GArEhC,SAsEjBY,EAAU1K,EAAMuK,EAvEC,WAuEgCT,GAvEhC,SAyErB,GAAImB,EAAS,CAEX,IAAIC,EAAyC,IAA1BzI,EAAM1U,SAASgP,OAC9BoO,EAAgB1I,EAAMe,SAAW,EACjC4H,EAAiB3I,EAAMY,UAAY,IAEvC,GAAI6H,GAAgBC,GAAiBC,EACnC,OAIJ,IAAIV,IAAWC,EAKf,OAAIM,GAAWN,GAr2BQU,EAq2BGrG,GAAoC0F,GAp2BzCY,GAo2BoDtG,EAChE5X,KAAKme,WAAWrd,QADzB,IASFqd,WAAY,SAAoBrd,GAC9Bd,KAAK+K,QAAQ2K,QAAQiI,WAAY,EACjC7c,EAAS8c,mBA+Fb,SAASQ,GAAWjZ,GAClBnF,KAAKmF,QAAUmJ,EAAO,GAAItO,KAAKqe,SAAUlZ,GAAW,IACpDnF,KAAK0N,GAj/BEwG,IAk/BPlU,KAAK+K,QAAU,KAEf/K,KAAKmF,QAAQ/D,OAAS4Q,EAAYhS,KAAKmF,QAAQ/D,QAAQ,GACvDpB,KAAKsN,MApBc,EAqBnBtN,KAAKse,aAAe,GACpBte,KAAKue,YAAc,GA8OrB,SAASC,GAASlR,GAChB,OAhQoB,GAgQhBA,EACK,SAnQO,EAoQLA,EACF,MAtQS,EAuQPA,EACF,OAzQO,EA0QLA,EACF,QAGF,GAST,SAASmR,GAAa7G,GACpB,OA3tCmB,IA2tCfA,EACK,OA7tCQ,GA8tCNA,EACF,KAjuCU,GAkuCRA,EACF,OAluCW,GAmuCTA,EACF,QAGF,GAUT,SAAS8G,GAA6BzS,EAAiBhB,GACrD,IAAIF,EAAUE,EAAWF,QAEzB,OAAIA,EACKA,EAAQ/B,IAAIiD,GAGdA,EAST,SAAS0S,KACPP,GAAW5N,MAAMxQ,KAAMyQ,WA6DzB,SAASmO,KACPD,GAAenO,MAAMxQ,KAAMyQ,WAC3BzQ,KAAK6e,GAAK,KACV7e,KAAK8e,GAAK,KAyEZ,SAASC,KACPJ,GAAenO,MAAMxQ,KAAMyQ,WAmC7B,SAASuO,KACPZ,GAAW5N,MAAMxQ,KAAMyQ,WACvBzQ,KAAKif,OAAS,KACdjf,KAAKkf,OAAS,KAgEhB,SAASC,KACPR,GAAenO,MAAMxQ,KAAMyQ,WA2B7B,SAAS2O,KACPT,GAAenO,MAAMxQ,KAAMyQ,WAqD7B,SAAS4O,KACPjB,GAAW5N,MAAMxQ,KAAMyQ,WAGvBzQ,KAAKsf,OAAQ,EACbtf,KAAKuf,SAAU,EACfvf,KAAKif,OAAS,KACdjf,KAAKkf,OAAS,KACdlf,KAAKwf,MAAQ,EAkGf,SAASve,GAAOmE,EAASD,GAGvB,OAFAA,EAAUA,GAAW,IACbkF,YAAc2H,EAAY7M,EAAQkF,YAAapJ,GAAOod,SAASoB,QAChE,IAAI1e,GAAQqE,EAASD,GAptB9BiZ,GAAW3M,UAAY,CAKrB4M,SAAU,GAOVpB,IAAK,SAAa9X,GAIhB,OAHAmJ,EAAOtO,KAAKmF,QAASA,GAErBnF,KAAK+K,SAAW/K,KAAK+K,QAAQR,YAAY6S,SAClCpd,MAQT0f,cAAe,SAAuBzT,GACpC,GAAImD,EAAenD,EAAiB,gBAAiBjM,MACnD,OAAOA,KAGT,IAAIse,EAAete,KAAKse,aAQxB,OALKA,GAFLrS,EAAkByS,GAA6BzS,EAAiBjM,OAE9B0N,MAChC4Q,EAAarS,EAAgByB,IAAMzB,EACnCA,EAAgByT,cAAc1f,OAGzBA,MAQT2f,kBAAmB,SAA2B1T,GAC5C,OAAImD,EAAenD,EAAiB,oBAAqBjM,QAIzDiM,EAAkByS,GAA6BzS,EAAiBjM,aACzDA,KAAKse,aAAarS,EAAgByB,KAJhC1N,MAaX4f,eAAgB,SAAwB3T,GACtC,GAAImD,EAAenD,EAAiB,iBAAkBjM,MACpD,OAAOA,KAGT,IAAIue,EAAcve,KAAKue,YAQvB,OAL+C,IAA3CrL,EAAQqL,EAFZtS,EAAkByS,GAA6BzS,EAAiBjM,SAG9Due,EAAY9K,KAAKxH,GACjBA,EAAgB2T,eAAe5f,OAG1BA,MAQT6f,mBAAoB,SAA4B5T,GAC9C,GAAImD,EAAenD,EAAiB,qBAAsBjM,MACxD,OAAOA,KAGTiM,EAAkByS,GAA6BzS,EAAiBjM,MAChE,IAAI8N,EAAQoF,EAAQlT,KAAKue,YAAatS,GAMtC,OAJI6B,GAAS,GACX9N,KAAKue,YAAYvE,OAAOlM,EAAO,GAG1B9N,MAOT8f,mBAAoB,WAClB,OAAO9f,KAAKue,YAAY5O,OAAS,GAQnCoQ,iBAAkB,SAA0B9T,GAC1C,QAASjM,KAAKse,aAAarS,EAAgByB,KAQ7CnB,KAAM,SAAc8I,GAClB,IAAIL,EAAOhV,KACPsN,EAAQtN,KAAKsN,MAEjB,SAASf,EAAKrL,GACZ8T,EAAKjK,QAAQwB,KAAKrL,EAAOmU,GAIvB/H,EArJU,GAsJZf,EAAKyI,EAAK7P,QAAQjE,MAAQsd,GAASlR,IAGrCf,EAAKyI,EAAK7P,QAAQjE,OAEdmU,EAAM2K,iBAERzT,EAAK8I,EAAM2K,iBAIT1S,GAjKU,GAkKZf,EAAKyI,EAAK7P,QAAQjE,MAAQsd,GAASlR,KAUvC2S,QAAS,SAAiB5K,GACxB,GAAIrV,KAAKkgB,UACP,OAAOlgB,KAAKuM,KAAK8I,GAInBrV,KAAKsN,MA/KU,IAsLjB4S,QAAS,WAGP,IAFA,IAAIhgB,EAAI,EAEDA,EAAIF,KAAKue,YAAY5O,QAAQ,CAClC,KAAkC,GAA5B3P,KAAKue,YAAYre,GAAGoN,OACxB,OAAO,EAGTpN,IAGF,OAAO,GAOTgY,UAAW,SAAmBiE,GAG5B,IAAIgE,EAAiB7R,EAAO,GAAI6N,GAEhC,IAAKtK,EAAS7R,KAAKmF,QAAQ/D,OAAQ,CAACpB,KAAMmgB,IAGxC,OAFAngB,KAAKogB,aACLpgB,KAAKsN,MA/MQ,IAoNE,GAAbtN,KAAKsN,QACPtN,KAAKsN,MA3NU,GA8NjBtN,KAAKsN,MAAQtN,KAAKqgB,QAAQF,GAGT,GAAbngB,KAAKsN,OACPtN,KAAKigB,QAAQE,IAWjBE,QAAS,SAAiBlE,KAQ1BkB,eAAgB,aAOhB+C,MAAO,cAqETjP,EAAQwN,GAAgBP,GAAY,CAKlCC,SAAU,CAKR1d,SAAU,GASZ2f,SAAU,SAAkBjL,GAC1B,IAAIkL,EAAiBvgB,KAAKmF,QAAQxE,SAClC,OAA0B,IAAnB4f,GAAwBlL,EAAM1U,SAASgP,SAAW4Q,GAS3DF,QAAS,SAAiBhL,GACxB,IAAI/H,EAAQtN,KAAKsN,MACb9M,EAAY6U,EAAM7U,UAClBggB,EAAuB,EAARlT,EACfmT,EAAUzgB,KAAKsgB,SAASjL,GAE5B,OAAImL,IA5yCW,EA4yCMhgB,IAA6BigB,GAhWhC,GAiWTnT,EACEkT,GAAgBC,EA/yCf,EAgzCNjgB,EArWQ,EAsWH8M,EAxWG,EAyWCA,EAxWC,EA4WPA,EA7WK,EAKC,MA2XnB6D,EAAQyN,GAAeD,GAAgB,CAKrCN,SAAU,CACRnd,MAAO,MACPC,UAAW,GACXR,SAAU,EACViX,UAz0CgB8I,IA20ClBrD,eAAgB,WACd,IAAIzF,EAAY5X,KAAKmF,QAAQyS,UACzBuF,EAAU,GAUd,OAz1CuBc,EAi1CnBrG,GACFuF,EAAQ1J,KArkBW,SA5wBAyK,GAo1CjBtG,GACFuF,EAAQ1J,KA1kBW,SA6kBd0J,GAETwD,cAAe,SAAuBtL,GACpC,IAAIlQ,EAAUnF,KAAKmF,QACfyb,GAAW,EACXxK,EAAWf,EAAMe,SACjBwB,EAAYvC,EAAMuC,UAClB3R,EAAIoP,EAAMqB,OACVxQ,EAAImP,EAAMsB,OAed,OAbMiB,EAAYzS,EAAQyS,YAn2CHqG,EAo2CjB9Y,EAAQyS,WACVA,EAAkB,IAAN3R,EA12CC,EA02C0BA,EAAI,EAz2C9B,EACC,EAy2Cd2a,EAAW3a,GAAKjG,KAAK6e,GACrBzI,EAAWhQ,KAAKuI,IAAI0G,EAAMqB,UAE1BkB,EAAkB,IAAN1R,EA92CC,EA82C0BA,EAAI,EA32ChC,EACE,GA22Cb0a,EAAW1a,GAAKlG,KAAK8e,GACrB1I,EAAWhQ,KAAKuI,IAAI0G,EAAMsB,UAI9BtB,EAAMuC,UAAYA,EACXgJ,GAAYxK,EAAWjR,EAAQhE,WAAayW,EAAYzS,EAAQyS,WAEzE0I,SAAU,SAAkBjL,GAC1B,OAAOsJ,GAAelN,UAAU6O,SAAS1Q,KAAK5P,KAAMqV,KAjbtC,EAibiDrV,KAAKsN,SAjbtD,EAib+EtN,KAAKsN,QAAwBtN,KAAK2gB,cAActL,KAE/I9I,KAAM,SAAc8I,GAClBrV,KAAK6e,GAAKxJ,EAAMqB,OAChB1W,KAAK8e,GAAKzJ,EAAMsB,OAChB,IAAIiB,EAAY6G,GAAapJ,EAAMuC,WAE/BA,IACFvC,EAAM2K,gBAAkBhgB,KAAKmF,QAAQjE,MAAQ0W,GAG/C5X,KAAK4R,OAAOrF,KAAKqD,KAAK5P,KAAMqV,MAchClE,EAAQ4N,GAAiBJ,GAAgB,CAKvCN,SAAU,CACRnd,MAAO,QACPC,UAAW,EACXR,SAAU,GAEZ0c,eAAgB,WACd,MAAO,CA5oBa,SA8oBtBiD,SAAU,SAAkBjL,GAC1B,OAAOrV,KAAK4R,OAAO0O,SAAS1Q,KAAK5P,KAAMqV,KAAWjP,KAAKuI,IAAI0G,EAAM8B,MAAQ,GAAKnX,KAAKmF,QAAQhE,WAxd7E,EAwd0FnB,KAAKsN,QAE/Gf,KAAM,SAAc8I,GAClB,GAAoB,IAAhBA,EAAM8B,MAAa,CACrB,IAAI0J,EAAQxL,EAAM8B,MAAQ,EAAI,KAAO,MACrC9B,EAAM2K,gBAAkBhgB,KAAKmF,QAAQjE,MAAQ2f,EAG/C7gB,KAAK4R,OAAOrF,KAAKqD,KAAK5P,KAAMqV,MAgBhClE,EAAQ6N,GAAiBZ,GAAY,CAKnCC,SAAU,CACRnd,MAAO,QACPP,SAAU,EACVmgB,KAAM,IAEN3f,UAAW,GAGbkc,eAAgB,WACd,MAAO,CAxrBa,SA0rBtBgD,QAAS,SAAiBhL,GACxB,IAAIlQ,EAAUnF,KAAKmF,QACf4b,EAAgB1L,EAAM1U,SAASgP,SAAWxK,EAAQxE,SAClDqgB,EAAgB3L,EAAMe,SAAWjR,EAAQhE,UACzC8f,EAAY5L,EAAMY,UAAY9Q,EAAQ2b,KAI1C,GAHA9gB,KAAKkf,OAAS7J,GAGT2L,IAAkBD,GAAmC,GAAlB1L,EAAM7U,YAA2CygB,EACvFjhB,KAAKogB,aACA,GAr9CO,EAq9CH/K,EAAM7U,UACfR,KAAKogB,QACLpgB,KAAKif,OAASnQ,GAAkB,WAC9B9O,KAAKsN,MA3gBK,EA4gBVtN,KAAKigB,YACJ9a,EAAQ2b,KAAM9gB,WACZ,GAz9CK,EAy9CDqV,EAAM7U,UACf,OA/gBY,EAkhBd,OA/gBe,IAihBjB4f,MAAO,WACLc,aAAalhB,KAAKif,SAEpB1S,KAAM,SAAc8I,GAvhBJ,IAwhBVrV,KAAKsN,QAIL+H,GAv+CQ,EAu+CCA,EAAM7U,UACjBR,KAAK+K,QAAQwB,KAAKvM,KAAKmF,QAAQjE,MAAQ,KAAMmU,IAE7CrV,KAAKkf,OAAOlJ,UAAYpH,IACxB5O,KAAK+K,QAAQwB,KAAKvM,KAAKmF,QAAQjE,MAAOlB,KAAKkf,aAejD/N,EAAQgO,GAAkBR,GAAgB,CAKxCN,SAAU,CACRnd,MAAO,SACPC,UAAW,EACXR,SAAU,GAEZ0c,eAAgB,WACd,MAAO,CAnvBa,SAqvBtBiD,SAAU,SAAkBjL,GAC1B,OAAOrV,KAAK4R,OAAO0O,SAAS1Q,KAAK5P,KAAMqV,KAAWjP,KAAKuI,IAAI0G,EAAMiC,UAAYtX,KAAKmF,QAAQhE,WA/jB5E,EA+jByFnB,KAAKsN,UAchH6D,EAAQiO,GAAiBT,GAAgB,CAKvCN,SAAU,CACRnd,MAAO,QACPC,UAAW,GACXsW,SAAU,GACVG,UAAW8I,GACX/f,SAAU,GAEZ0c,eAAgB,WACd,OAAOuB,GAAcnN,UAAU4L,eAAezN,KAAK5P,OAErDsgB,SAAU,SAAkBjL,GAC1B,IACIoC,EADAG,EAAY5X,KAAKmF,QAAQyS,UAW7B,OARgB,GAAZA,EACFH,EAAWpC,EAAM0B,gBAniDIkH,EAoiDZrG,EACTH,EAAWpC,EAAM4B,iBApiDEiH,GAqiDVtG,IACTH,EAAWpC,EAAM6B,kBAGZlX,KAAK4R,OAAO0O,SAAS1Q,KAAK5P,KAAMqV,IAAUuC,EAAYvC,EAAMwB,iBAAmBxB,EAAMe,SAAWpW,KAAKmF,QAAQhE,WAAakU,EAAMmC,aAAexX,KAAKmF,QAAQxE,UAAYgO,EAAI8I,GAAYzX,KAAKmF,QAAQsS,UAjjDhM,EAijD4MpC,EAAM7U,WAEhO+L,KAAM,SAAc8I,GAClB,IAAIuC,EAAY6G,GAAapJ,EAAMwB,iBAE/Be,GACF5X,KAAK+K,QAAQwB,KAAKvM,KAAKmF,QAAQjE,MAAQ0W,EAAWvC,GAGpDrV,KAAK+K,QAAQwB,KAAKvM,KAAKmF,QAAQjE,MAAOmU,MAyB1ClE,EAAQkO,GAAejB,GAAY,CAKjCC,SAAU,CACRnd,MAAO,MACPP,SAAU,EACVU,KAAM,EACN8f,SAAU,IAEVL,KAAM,IAEN3f,UAAW,EAEXigB,aAAc,IAGhB/D,eAAgB,WACd,MAAO,CAt1BqB,iBAw1B9BgD,QAAS,SAAiBhL,GACxB,IAAIlQ,EAAUnF,KAAKmF,QACf4b,EAAgB1L,EAAM1U,SAASgP,SAAWxK,EAAQxE,SAClDqgB,EAAgB3L,EAAMe,SAAWjR,EAAQhE,UACzCkgB,EAAiBhM,EAAMY,UAAY9Q,EAAQ2b,KAG/C,GAFA9gB,KAAKogB,QA/mDS,EAinDV/K,EAAM7U,WAA0C,IAAfR,KAAKwf,MACxC,OAAOxf,KAAKshB,cAKd,GAAIN,GAAiBK,GAAkBN,EAAe,CACpD,GAtnDU,GAsnDN1L,EAAM7U,UACR,OAAOR,KAAKshB,cAGd,IAAIC,GAAgBvhB,KAAKsf,OAAQjK,EAAMW,UAAYhW,KAAKsf,MAAQna,EAAQgc,SACpEK,GAAiBxhB,KAAKuf,SAAWlJ,EAAYrW,KAAKuf,QAASlK,EAAM9O,QAAUpB,EAAQic,aAevF,GAdAphB,KAAKsf,MAAQjK,EAAMW,UACnBhW,KAAKuf,QAAUlK,EAAM9O,OAEhBib,GAAkBD,EAGrBvhB,KAAKwf,OAAS,EAFdxf,KAAKwf,MAAQ,EAKfxf,KAAKkf,OAAS7J,EAKG,IAFFrV,KAAKwf,MAAQra,EAAQ9D,KAKlC,OAAKrB,KAAK8f,sBAGR9f,KAAKif,OAASnQ,GAAkB,WAC9B9O,KAAKsN,MAtsBC,EAusBNtN,KAAKigB,YACJ9a,EAAQgc,SAAUnhB,MA1sBb,GAEA,EA8sBd,OA3sBe,IA6sBjBshB,YAAa,WAIX,OAHAthB,KAAKif,OAASnQ,GAAkB,WAC9B9O,KAAKsN,MA/sBQ,KAgtBZtN,KAAKmF,QAAQgc,SAAUnhB,MAhtBX,IAmtBjBogB,MAAO,WACLc,aAAalhB,KAAKif,SAEpB1S,KAAM,WAztBU,GA0tBVvM,KAAKsN,QACPtN,KAAKkf,OAAOuC,SAAWzhB,KAAKwf,MAC5Bxf,KAAK+K,QAAQwB,KAAKvM,KAAKmF,QAAQjE,MAAOlB,KAAKkf,YAqBjDje,GAAOygB,QAAU,QAMjBzgB,GAAOod,SAAW,CAOhBsD,WAAW,EAQXpX,YAn8ByB,UAy8BzBnJ,QAAQ,EASR6T,YAAa,KAOb2M,WAAY,KAOZnC,OAAQ,CACR,CAACN,GAAkB,CACjB/d,QAAQ,IACN,CAAC2d,GAAiB,CACpB3d,QAAQ,GACP,CAAC,WAAY,CAACge,GAAiB,CAChCxH,UA7uDuBqG,IA8uDrB,CAACW,GAAe,CAClBhH,UA/uDuBqG,GAgvDtB,CAAC,UAAW,CAACoB,IAAgB,CAACA,GAAe,CAC9Cne,MAAO,YACPG,KAAM,GACL,CAAC,QAAS,CAAC2d,KAOd6C,SAAU,CAMRC,WAAY,OAOZC,YAAa,OASbC,aAAc,OAOdC,eAAgB,OAOhBC,SAAU,OAQVC,kBAAmB,kBAYvB,SAASphB,GAAQqE,EAASD,GApvD1B,IAA6B4F,EAqvD3B/K,KAAKmF,QAAUmJ,EAAO,GAAIrN,GAAOod,SAAUlZ,GAAW,IACtDnF,KAAKmF,QAAQ8P,YAAcjV,KAAKmF,QAAQ8P,aAAe7P,EACvDpF,KAAKiI,SAAW,GAChBjI,KAAK0V,QAAU,GACf1V,KAAKqK,YAAc,GACnBrK,KAAKoiB,YAAc,GACnBpiB,KAAKoF,QAAUA,EACfpF,KAAKqV,MA5uDE,KAhBoBtK,EA4vDM/K,MA1vDRmF,QAAQyc,aAItBnN,EACFnV,GACEoV,EACFkG,GACGpG,EAGH6G,GAFA9a,IAKOwK,EAASqK,GA6uDzBpV,KAAKuK,YAAc,IAAIyS,GAAYhd,KAAMA,KAAKmF,QAAQoF,aACtD8X,GAAeriB,MAAM,GACrBwP,EAAKxP,KAAKmF,QAAQkF,aAAa,SAAUiY,GACvC,IAAIrX,EAAajL,KAAKqI,IAAI,IAAIia,EAAK,GAAGA,EAAK,KAC3CA,EAAK,IAAMrX,EAAWyU,cAAc4C,EAAK,IACzCA,EAAK,IAAMrX,EAAW2U,eAAe0C,EAAK,MACzCtiB,MAiQL,SAASqiB,GAAetX,EAAS1C,GAC/B,IAMI0L,EANA3O,EAAU2F,EAAQ3F,QAEjBA,EAAQoX,QAKbhN,EAAKzE,EAAQ5F,QAAQ0c,UAAU,SAAU/b,EAAOkF,GAC9C+I,EAAOH,EAASxO,EAAQoX,MAAOxR,GAE3B3C,GACF0C,EAAQqX,YAAYrO,GAAQ3O,EAAQoX,MAAMzI,GAC1C3O,EAAQoX,MAAMzI,GAAQjO,GAEtBV,EAAQoX,MAAMzI,GAAQhJ,EAAQqX,YAAYrO,IAAS,MAIlD1L,IACH0C,EAAQqX,YAAc,KAlR1BrhB,GAAQ0Q,UAAY,CAMlBwL,IAAK,SAAa9X,GAchB,OAbAmJ,EAAOtO,KAAKmF,QAASA,GAEjBA,EAAQoF,aACVvK,KAAKuK,YAAY6S,SAGfjY,EAAQ8P,cAEVjV,KAAKqV,MAAMzP,UACX5F,KAAKqV,MAAM5O,OAAStB,EAAQ8P,YAC5BjV,KAAKqV,MAAMF,QAGNnV,MASTuiB,KAAM,SAAcC,GAClBxiB,KAAK0V,QAAQ+M,QAAUD,EAxDT,EADP,GAkETtK,UAAW,SAAmBiE,GAC5B,IAAIzG,EAAU1V,KAAK0V,QAEnB,IAAIA,EAAQ+M,QAAZ,CAMA,IAAIxX,EADJjL,KAAKuK,YAAYmT,gBAAgBvB,GAEjC,IAAI9R,EAAcrK,KAAKqK,YAInBqY,EAAgBhN,EAAQgN,gBAGvBA,GAAiBA,GAx7BR,EAw7ByBA,EAAcpV,SACnDoV,EAAgBhN,EAAQgN,cAAgB,MAK1C,IAFA,IAAIxiB,EAAI,EAEDA,EAAImK,EAAYsF,QACrB1E,EAAaZ,EAAYnK,GAzFb,IAgGRwV,EAAQ+M,SACXC,GAAiBzX,GAAcyX,IAChCzX,EAAW8U,iBAAiB2C,GAI1BzX,EAAWmV,QAFXnV,EAAWiN,UAAUiE,IAOlBuG,GAAoC,GAAnBzX,EAAWqC,QAC/BoV,EAAgBhN,EAAQgN,cAAgBzX,GAG1C/K,MASJ8I,IAAK,SAAaiC,GAChB,GAAIA,aAAsBmT,GACxB,OAAOnT,EAKT,IAFA,IAAIZ,EAAcrK,KAAKqK,YAEdnK,EAAI,EAAGA,EAAImK,EAAYsF,OAAQzP,IACtC,GAAImK,EAAYnK,GAAGiF,QAAQjE,OAAS+J,EAClC,OAAOZ,EAAYnK,GAIvB,OAAO,MASTmI,IAAK,SAAa4C,GAChB,GAAImE,EAAenE,EAAY,MAAOjL,MACpC,OAAOA,KAIT,IAAI2iB,EAAW3iB,KAAKgJ,IAAIiC,EAAW9F,QAAQjE,OAS3C,OAPIyhB,GACF3iB,KAAK4I,OAAO+Z,GAGd3iB,KAAKqK,YAAYoJ,KAAKxI,GACtBA,EAAWF,QAAU/K,KACrBA,KAAKuK,YAAY6S,SACVnS,GAQTrC,OAAQ,SAAgBqC,GACtB,GAAImE,EAAenE,EAAY,SAAUjL,MACvC,OAAOA,KAKT,GAFAiL,EAAajL,KAAKgJ,IAAIiC,GAEN,CACd,IAAIZ,EAAcrK,KAAKqK,YACnByD,EAAQoF,EAAQ7I,EAAaY,IAElB,IAAX6C,IACFzD,EAAY2P,OAAOlM,EAAO,GAC1B9N,KAAKuK,YAAY6S,UAIrB,OAAOpd,MAST6K,GAAI,SAAYvF,EAAQoD,GACtB,QAt5EN,IAs5EUpD,QAt5EV,IA05EUoD,EAAJ,CAIA,IAAIT,EAAWjI,KAAKiI,SAKpB,OAJAuH,EAAK6C,EAAS/M,IAAS,SAAUpE,GAC/B+G,EAAS/G,GAAS+G,EAAS/G,IAAU,GACrC+G,EAAS/G,GAAOuS,KAAK/K,MAEhB1I,OAST6L,IAAK,SAAavG,EAAQoD,GACxB,QA76EN,IA66EUpD,EAAJ,CAIA,IAAI2C,EAAWjI,KAAKiI,SAQpB,OAPAuH,EAAK6C,EAAS/M,IAAS,SAAUpE,GAC1BwH,EAGHT,EAAS/G,IAAU+G,EAAS/G,GAAO8Y,OAAO9G,EAAQjL,EAAS/G,GAAQwH,GAAU,UAFtET,EAAS/G,MAKblB,OAQTuM,KAAM,SAAcrL,EAAO0hB,GAErB5iB,KAAKmF,QAAQwc,WAyErB,SAAyBzgB,EAAO0hB,GAC9B,IAAIC,EAAe1U,EAAS2U,YAAY,SACxCD,EAAaE,UAAU7hB,GAAO,GAAM,GACpC2hB,EAAaG,QAAUJ,EACvBA,EAAKnc,OAAOwc,cAAcJ,GA5EtBK,CAAgBhiB,EAAO0hB,GAIzB,IAAI3a,EAAWjI,KAAKiI,SAAS/G,IAAUlB,KAAKiI,SAAS/G,GAAOsM,QAE5D,GAAKvF,GAAaA,EAAS0H,OAA3B,CAIAiT,EAAKtc,KAAOpF,EAEZ0hB,EAAKhF,eAAiB,WACpBgF,EAAK9hB,SAAS8c,kBAKhB,IAFA,IAAI1d,EAAI,EAEDA,EAAI+H,EAAS0H,QAClB1H,EAAS/H,GAAG0iB,GACZ1iB,MAQJ0F,QAAS,WACP5F,KAAKoF,SAAWid,GAAeriB,MAAM,GACrCA,KAAKiI,SAAW,GAChBjI,KAAK0V,QAAU,GACf1V,KAAKqV,MAAMzP,UACX5F,KAAKoF,QAAU,OA8CnBkJ,EAAOrN,GAAQ,CACbkiB,YAjnEgB,EAknEhBC,WAjnEe,EAknEfC,UAjnEc,EAknEdC,aAjnEiB,EAknEjBC,eA3qCmB,EA4qCnBC,YA3qCgB,EA4qChBC,cA3qCkB,EA4qClBC,YA3qCgB,EA4qChBC,iBA5qCgB,EA6qChBC,gBA3qCoB,GA4qCpBC,aA3qCiB,GA4qCjBC,eAxnEmB,EAynEnB7F,eAxnEmB,EAynEnB8F,gBAxnEoB,EAynEpB7F,aAxnEiB,EAynEjB8F,eAxnEmB,GAynEnBtD,qBAxnEyBzC,EAynEzBgG,mBAxnEuB/F,GAynEvBgG,cAxnEkBxD,GAynElB3f,QAASA,GACTgU,MAAOA,EACPiI,YAAaA,GACbpC,WAAYA,GACZra,WAAYA,EACZjB,kBAAmBA,GACnB+b,gBAAiBA,GACjBlB,iBAAkBA,GAClBiE,WAAYA,GACZO,eAAgBA,GAChBwF,IAAK9E,GACL+E,IAAKxF,GACLyF,MAAOjF,GACPkF,MAAOvF,GACPwF,OAAQpF,GACRqF,MAAOxF,GACPnU,GAAIsH,EACJtG,IAAK0G,EACL/C,KAAMA,EACNyB,MAAOA,EACPH,OAAQA,EACRxC,OAAQA,EACR6C,QAASA,EACThC,OAAQA,EACRyE,SAAUA,UAIuB,IAAX7N,EAAyBA,EAAyB,oBAATiP,KAAuBA,KAAO,IAEpF/T,OAASA,QArkFtB,KAwkFI,aACE,OAAOA,IACR,8BA1kFL,CAglFG8E,OAAQoI,W,mCCrlFX,kHAwBO,IAAMnJ,EACX,oBAAO4P,WAA6BA,UAApC,UAA0DA,oBAA1D,cADK,GAGD6P,EAAU,oBAAO1e,OAAP,OAAhB,EAWIL,QAVY,IAAOgf,GAAvB,OACkB,oBAAOvW,UAAP,UASlB,GAGA,IACE,IAAMhJ,EAAU,CAGd,cAEE,OADAO,MACO,IAIX+e,+BACAA,kCACA,a","file":"component---examples-main-app-js-823b1a43a8254f3750a8.js","sourcesContent":["/**\n * This file contains overrides the default\n * hammer.js functions to add our own utility\n */\n\n/* Hammer.js constants */\nconst INPUT_START = 1;\nconst INPUT_MOVE = 2;\nconst INPUT_END = 4;\nconst MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\n\n/**\n * Helper function that returns true if any element in an array meets given criteria.\n * Because older browsers do not support `Array.prototype.some`\n * @params array {Array}\n * @params predict {Function}\n */\nfunction some(array, predict) {\n  for (let i = 0; i < array.length; i++) {\n    if (predict(array[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/* eslint-disable no-invalid-this */\nexport function enhancePointerEventInput(PointerEventInput) {\n  const oldHandler = PointerEventInput.prototype.handler;\n\n  // overrides PointerEventInput.handler to accept right mouse button\n  PointerEventInput.prototype.handler = function handler(ev) {\n    const store = this.store;\n\n    // Allow non-left mouse buttons through\n    if (ev.button > 0) {\n      if (!some(store, e => e.pointerId === ev.pointerId)) {\n        store.push(ev);\n      }\n    }\n\n    oldHandler.call(this, ev);\n  };\n}\n\n// overrides MouseInput.handler to accept right mouse button\nexport function enhanceMouseInput(MouseInput) {\n  MouseInput.prototype.handler = function handler(ev) {\n    let eventType = MOUSE_INPUT_MAP[ev.type];\n\n    // on start we want to have the mouse button down\n    if (eventType & INPUT_START && ev.button >= 0) {\n      this.pressed = true;\n    }\n\n    if (eventType & INPUT_MOVE && ev.which === 0) {\n      eventType = INPUT_END;\n    }\n\n    // mouse must be down\n    if (!this.pressed) {\n      return;\n    }\n\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: 'mouse',\n      srcEvent: ev\n    });\n  };\n}\n","import hammerjs from 'hammerjs';\nimport {enhancePointerEventInput, enhanceMouseInput} from './hammer-overrides';\n\nenhancePointerEventInput(hammerjs.PointerEventInput);\nenhanceMouseInput(hammerjs.MouseInput);\n\nexport const Manager = hammerjs.Manager;\n\nexport default hammerjs;\n","// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport Hammer from './utils/hammer';\n\n// This module contains constants that must be conditionally required\n// due to `window`/`document` references downstream.\nexport const RECOGNIZERS = Hammer\n  ? [\n      [Hammer.Pan, {event: 'tripan', pointers: 3, threshold: 0, enable: false}],\n      [Hammer.Rotate, {enable: false}],\n      [Hammer.Pinch, {enable: false}],\n      [Hammer.Swipe, {enable: false}],\n      [Hammer.Pan, {threshold: 0, enable: false}],\n      [Hammer.Press, {enable: false}],\n      [Hammer.Tap, {event: 'doubletap', taps: 2, enable: false}],\n      // TODO - rename to 'tap' and 'singletap' in the next major release\n      [Hammer.Tap, {event: 'anytap', enable: false}],\n      [Hammer.Tap, {enable: false}]\n    ]\n  : null;\n\n// Recognize the following gestures even if a given recognizer succeeds\nexport const RECOGNIZER_COMPATIBLE_MAP = {\n  tripan: ['rotate', 'pinch', 'pan'],\n  rotate: ['pinch'],\n  pinch: ['pan'],\n  pan: ['press', 'doubletap', 'anytap', 'tap'],\n  doubletap: ['anytap'],\n  anytap: ['tap']\n};\n\n// Recognize the folling gestures only if a given recognizer fails\nexport const RECOGNIZER_FALLBACK_MAP = {\n  doubletap: ['tap']\n};\n\n/**\n * Only one set of basic input events will be fired by Hammer.js:\n * either pointer, touch, or mouse, depending on system support.\n * In order to enable an application to be agnostic of system support,\n * alias basic input events into \"classes\" of events: down, move, and up.\n * See `_onBasicInput()` for usage of these aliases.\n */\nexport const BASIC_EVENT_ALIASES = {\n  pointerdown: 'pointerdown',\n  pointermove: 'pointermove',\n  pointerup: 'pointerup',\n  touchstart: 'pointerdown',\n  touchmove: 'pointermove',\n  touchend: 'pointerup',\n  mousedown: 'pointerdown',\n  mousemove: 'pointermove',\n  mouseup: 'pointerup'\n};\n\nexport const INPUT_EVENT_TYPES = {\n  KEY_EVENTS: ['keydown', 'keyup'],\n  MOUSE_EVENTS: ['mousedown', 'mousemove', 'mouseup', 'mouseover', 'mouseout', 'mouseleave'],\n  WHEEL_EVENTS: [\n    // Chrome, Safari\n    'wheel',\n    // IE\n    'mousewheel',\n    // legacy Firefox\n    'DOMMouseScroll'\n  ]\n};\n\n/**\n * \"Gestural\" events are those that have semantic meaning beyond the basic input event,\n * e.g. a click or tap is a sequence of `down` and `up` events with no `move` event in between.\n * Hammer.js handles these with its Recognizer system;\n * this block maps event names to the Recognizers required to detect the events.\n */\nexport const EVENT_RECOGNIZER_MAP = {\n  tap: 'tap',\n  anytap: 'anytap',\n  doubletap: 'doubletap',\n  press: 'press',\n  pinch: 'pinch',\n  pinchin: 'pinch',\n  pinchout: 'pinch',\n  pinchstart: 'pinch',\n  pinchmove: 'pinch',\n  pinchend: 'pinch',\n  pinchcancel: 'pinch',\n  rotate: 'rotate',\n  rotatestart: 'rotate',\n  rotatemove: 'rotate',\n  rotateend: 'rotate',\n  rotatecancel: 'rotate',\n  tripan: 'tripan',\n  tripanstart: 'tripan',\n  tripanmove: 'tripan',\n  tripanup: 'tripan',\n  tripandown: 'tripan',\n  tripanleft: 'tripan',\n  tripanright: 'tripan',\n  tripanend: 'tripan',\n  tripancancel: 'tripan',\n  pan: 'pan',\n  panstart: 'pan',\n  panmove: 'pan',\n  panup: 'pan',\n  pandown: 'pan',\n  panleft: 'pan',\n  panright: 'pan',\n  panend: 'pan',\n  pancancel: 'pan',\n  swipe: 'swipe',\n  swipeleft: 'swipe',\n  swiperight: 'swipe',\n  swipeup: 'swipe',\n  swipedown: 'swipe'\n};\n\n/**\n * Map gestural events typically provided by browsers\n * that are not reported in 'hammer.input' events\n * to corresponding Hammer.js gestures.\n */\nexport const GESTURE_EVENT_ALIASES = {\n  click: 'tap',\n  anyclick: 'anytap',\n  dblclick: 'doubletap',\n  mousedown: 'pointerdown',\n  mousemove: 'pointermove',\n  mouseup: 'pointerup',\n  mouseover: 'pointerover',\n  mouseout: 'pointerout',\n  mouseleave: 'pointerleave'\n};\n","// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {INPUT_EVENT_TYPES} from '../constants';\nimport {window, userAgent, passiveSupported} from '../utils/globals';\n\nconst firefox = userAgent.indexOf('firefox') !== -1;\n\nconst {WHEEL_EVENTS} = INPUT_EVENT_TYPES;\nconst EVENT_TYPE = 'wheel';\n\n// Constants for normalizing input delta\nconst WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;\nconst WHEEL_DELTA_PER_LINE = 40;\n// Slow down zoom if shift key is held for more precise zooming\nconst SHIFT_MULTIPLIER = 0.25;\n\nexport default class WheelInput {\n  constructor(element, callback, options = {}) {\n    this.element = element;\n    this.callback = callback;\n\n    this.options = Object.assign({enable: true}, options);\n\n    this.events = WHEEL_EVENTS.concat(options.events || []);\n\n    this.handleEvent = this.handleEvent.bind(this);\n    this.events.forEach(event =>\n      element.addEventListener(event, this.handleEvent, passiveSupported ? {passive: false} : false)\n    );\n  }\n\n  destroy() {\n    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n  }\n\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType, enabled) {\n    if (eventType === EVENT_TYPE) {\n      this.options.enable = enabled;\n    }\n  }\n\n  /* eslint-disable complexity, max-statements */\n  handleEvent(event) {\n    if (!this.options.enable) {\n      return;\n    }\n\n    let value = event.deltaY;\n    if (window.WheelEvent) {\n      // Firefox doubles the values on retina screens...\n      if (firefox && event.deltaMode === window.WheelEvent.DOM_DELTA_PIXEL) {\n        value /= window.devicePixelRatio;\n      }\n      if (event.deltaMode === window.WheelEvent.DOM_DELTA_LINE) {\n        value *= WHEEL_DELTA_PER_LINE;\n      }\n    }\n\n    const wheelPosition = {\n      x: event.clientX,\n      y: event.clientY\n    };\n\n    if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {\n      // This one is definitely a mouse wheel event.\n      // Normalize this value to match trackpad.\n      value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);\n    }\n\n    if (event.shiftKey && value) {\n      value = value * SHIFT_MULTIPLIER;\n    }\n\n    this._onWheel(event, -value, wheelPosition);\n  }\n\n  _onWheel(srcEvent, delta, position) {\n    this.callback({\n      type: EVENT_TYPE,\n      center: position,\n      delta,\n      srcEvent,\n      pointerType: 'mouse',\n      target: srcEvent.target\n    });\n  }\n}\n","// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {INPUT_EVENT_TYPES} from '../constants';\n\nconst {MOUSE_EVENTS} = INPUT_EVENT_TYPES;\nconst MOVE_EVENT_TYPE = 'pointermove';\nconst OVER_EVENT_TYPE = 'pointerover';\nconst OUT_EVENT_TYPE = 'pointerout';\nconst LEAVE_EVENT_TYPE = 'pointerleave';\n\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\nexport default class MoveInput {\n  constructor(element, callback, options = {}) {\n    this.element = element;\n    this.callback = callback;\n    this.pressed = false;\n\n    this.options = Object.assign({enable: true}, options);\n    this.enableMoveEvent = this.options.enable;\n    this.enableLeaveEvent = this.options.enable;\n    this.enableOutEvent = this.options.enable;\n    this.enableOverEvent = this.options.enable;\n\n    this.events = MOUSE_EVENTS.concat(options.events || []);\n\n    this.handleEvent = this.handleEvent.bind(this);\n    this.events.forEach(event => element.addEventListener(event, this.handleEvent));\n  }\n\n  destroy() {\n    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n  }\n\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType, enabled) {\n    if (eventType === MOVE_EVENT_TYPE) {\n      this.enableMoveEvent = enabled;\n    }\n    if (eventType === OVER_EVENT_TYPE) {\n      this.enableOverEvent = enabled;\n    }\n    if (eventType === OUT_EVENT_TYPE) {\n      this.enableOutEvent = enabled;\n    }\n    if (eventType === LEAVE_EVENT_TYPE) {\n      this.enableLeaveEvent = enabled;\n    }\n  }\n\n  handleEvent(event) {\n    this.handleOverEvent(event);\n    this.handleOutEvent(event);\n    this.handleLeaveEvent(event);\n    this.handleMoveEvent(event);\n  }\n\n  handleOverEvent(event) {\n    if (this.enableOverEvent) {\n      if (event.type === 'mouseover') {\n        this.callback({\n          type: OVER_EVENT_TYPE,\n          srcEvent: event,\n          pointerType: 'mouse',\n          target: event.target\n        });\n      }\n    }\n  }\n\n  handleOutEvent(event) {\n    if (this.enableOutEvent) {\n      if (event.type === 'mouseout') {\n        this.callback({\n          type: OUT_EVENT_TYPE,\n          srcEvent: event,\n          pointerType: 'mouse',\n          target: event.target\n        });\n      }\n    }\n  }\n\n  handleLeaveEvent(event) {\n    if (this.enableLeaveEvent) {\n      if (event.type === 'mouseleave') {\n        this.callback({\n          type: LEAVE_EVENT_TYPE,\n          srcEvent: event,\n          pointerType: 'mouse',\n          target: event.target\n        });\n      }\n    }\n  }\n\n  handleMoveEvent(event) {\n    if (this.enableMoveEvent) {\n      switch (event.type) {\n        case 'mousedown':\n          if (event.button >= 0) {\n            // Button is down\n            this.pressed = true;\n          }\n          break;\n        case 'mousemove':\n          // Move events use `which` to track the button being pressed\n          if (event.which === 0) {\n            // Button is not down\n            this.pressed = false;\n          }\n          if (!this.pressed) {\n            // Drag events are emitted by hammer already\n            // we just need to emit the move event on hover\n            this.callback({\n              type: MOVE_EVENT_TYPE,\n              srcEvent: event,\n              pointerType: 'mouse',\n              target: event.target\n            });\n          }\n          break;\n        case 'mouseup':\n          this.pressed = false;\n          break;\n        default:\n      }\n    }\n  }\n}\n","// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {INPUT_EVENT_TYPES} from '../constants';\n\nconst {KEY_EVENTS} = INPUT_EVENT_TYPES;\nconst DOWN_EVENT_TYPE = 'keydown';\nconst UP_EVENT_TYPE = 'keyup';\n\nexport default class KeyInput {\n  constructor(element, callback, options = {}) {\n    this.element = element;\n    this.callback = callback;\n\n    this.options = Object.assign({enable: true}, options);\n    this.enableDownEvent = this.options.enable;\n    this.enableUpEvent = this.options.enable;\n\n    this.events = KEY_EVENTS.concat(options.events || []);\n\n    this.handleEvent = this.handleEvent.bind(this);\n\n    element.tabIndex = options.tabIndex || 0;\n    element.style.outline = 'none';\n    this.events.forEach(event => element.addEventListener(event, this.handleEvent));\n  }\n\n  destroy() {\n    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n  }\n\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType, enabled) {\n    if (eventType === DOWN_EVENT_TYPE) {\n      this.enableDownEvent = enabled;\n    }\n    if (eventType === UP_EVENT_TYPE) {\n      this.enableUpEvent = enabled;\n    }\n  }\n\n  handleEvent(event) {\n    // Ignore if focused on text input\n    const targetElement = event.target || event.srcElement;\n    if (\n      (targetElement.tagName === 'INPUT' && targetElement.type === 'text') ||\n      targetElement.tagName === 'TEXTAREA'\n    ) {\n      return;\n    }\n\n    if (this.enableDownEvent && event.type === 'keydown') {\n      this.callback({\n        type: DOWN_EVENT_TYPE,\n        srcEvent: event,\n        key: event.key,\n        target: event.target\n      });\n    }\n\n    if (this.enableUpEvent && event.type === 'keyup') {\n      this.callback({\n        type: UP_EVENT_TYPE,\n        srcEvent: event,\n        key: event.key,\n        target: event.target\n      });\n    }\n  }\n}\n","// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nconst EVENT_TYPE = 'contextmenu';\n\nexport default class ContextmenuInput {\n  constructor(element, callback, options = {}) {\n    this.element = element;\n    this.callback = callback;\n\n    this.options = Object.assign({enable: true}, options);\n\n    this.handleEvent = this.handleEvent.bind(this);\n    element.addEventListener('contextmenu', this.handleEvent);\n  }\n\n  destroy() {\n    this.element.removeEventListener('contextmenu', this.handleEvent);\n  }\n\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType, enabled) {\n    if (eventType === EVENT_TYPE) {\n      this.options.enable = enabled;\n    }\n  }\n\n  handleEvent(event) {\n    if (!this.options.enable) {\n      return;\n    }\n\n    this.callback({\n      type: EVENT_TYPE,\n      center: {\n        x: event.clientX,\n        y: event.clientY\n      },\n      srcEvent: event,\n      pointerType: 'mouse',\n      target: event.target\n    });\n  }\n}\n","/* Constants */\nconst DOWN_EVENT = 1;\nconst MOVE_EVENT = 2;\nconst UP_EVENT = 4;\nconst MOUSE_EVENTS = {\n  pointerdown: DOWN_EVENT,\n  pointermove: MOVE_EVENT,\n  pointerup: UP_EVENT,\n  mousedown: DOWN_EVENT,\n  mousemove: MOVE_EVENT,\n  mouseup: UP_EVENT\n};\n\n// MouseEvent.which https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\nconst MOUSE_EVENT_WHICH_LEFT = 1;\nconst MOUSE_EVENT_WHICH_MIDDLE = 2;\nconst MOUSE_EVENT_WHICH_RIGHT = 3;\n// MouseEvent.button https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\nconst MOUSE_EVENT_BUTTON_LEFT = 0;\nconst MOUSE_EVENT_BUTTON_MIDDLE = 1;\nconst MOUSE_EVENT_BUTTON_RIGHT = 2;\n// MouseEvent.buttons https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\nconst MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;\nconst MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;\nconst MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;\n\n/**\n * Extract the involved mouse button\n */\nexport function whichButtons(event) {\n  const eventType = MOUSE_EVENTS[event.srcEvent.type];\n  if (!eventType) {\n    // Not a mouse evet\n    return null;\n  }\n\n  const {buttons, button, which} = event.srcEvent;\n  let leftButton = false;\n  let middleButton = false;\n  let rightButton = false;\n\n  if (\n    // button is up, need to find out which one was pressed before\n    eventType === UP_EVENT ||\n    // moving but does not support `buttons` API\n    (eventType === MOVE_EVENT && !Number.isFinite(buttons))\n  ) {\n    leftButton = which === MOUSE_EVENT_WHICH_LEFT;\n    middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;\n    rightButton = which === MOUSE_EVENT_WHICH_RIGHT;\n  } else if (eventType === MOVE_EVENT) {\n    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);\n    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);\n    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);\n  } else if (eventType === DOWN_EVENT) {\n    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;\n    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;\n    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;\n  }\n\n  return {leftButton, middleButton, rightButton};\n}\n\n/**\n * Calculate event position relative to the root element\n */\nexport function getOffsetPosition(event, rootElement) {\n  const {srcEvent} = event;\n\n  // `center` is a hammer.js event property\n  if (!event.center && !Number.isFinite(srcEvent.clientX)) {\n    // Not a gestural event\n    return null;\n  }\n\n  const center = event.center || {\n    x: srcEvent.clientX,\n    y: srcEvent.clientY\n  };\n\n  const rect = rootElement.getBoundingClientRect();\n\n  // Fix scale for map affected by a CSS transform.\n  // See https://stackoverflow.com/a/26893663/3528533\n  const scaleX = rect.width / rootElement.offsetWidth;\n  const scaleY = rect.height / rootElement.offsetHeight;\n\n  // Calculate center relative to the root element\n  const offsetCenter = {\n    x: (center.x - rect.left - rootElement.clientLeft) / scaleX,\n    y: (center.y - rect.top - rootElement.clientTop) / scaleY\n  };\n\n  return {center, offsetCenter};\n}\n","import {whichButtons, getOffsetPosition} from './event-utils';\n\nconst DEFAULT_OPTIONS = {\n  srcElement: 'root',\n  priority: 0\n};\n\nexport default class EventRegistrar {\n  constructor(eventManager) {\n    this.eventManager = eventManager;\n    this.handlers = [];\n    // Element -> handler map\n    this.handlersByElement = new Map();\n\n    this.handleEvent = this.handleEvent.bind(this);\n    this._active = false;\n  }\n\n  // Returns true if there are no non-passive handlers\n  isEmpty() {\n    return !this._active;\n  }\n\n  add(type, handler, opts, once = false, passive = false) {\n    const {handlers, handlersByElement} = this;\n\n    if (opts && (typeof opts !== 'object' || opts.addEventListener)) {\n      // is DOM element, backward compatibility\n      opts = {srcElement: opts};\n    }\n    opts = opts ? Object.assign({}, DEFAULT_OPTIONS, opts) : DEFAULT_OPTIONS;\n\n    let entries = handlersByElement.get(opts.srcElement);\n    if (!entries) {\n      entries = [];\n      handlersByElement.set(opts.srcElement, entries);\n    }\n    const entry = {type, handler, srcElement: opts.srcElement, priority: opts.priority};\n    if (once) {\n      entry.once = true;\n    }\n    if (passive) {\n      entry.passive = true;\n    }\n    handlers.push(entry);\n    this._active = this._active || !entry.passive;\n\n    // Sort handlers by descending priority\n    // Handlers with the same priority are excuted in the order of registration\n    let insertPosition = entries.length - 1;\n    while (insertPosition >= 0) {\n      if (entries[insertPosition].priority >= entry.priority) {\n        break;\n      }\n      insertPosition--;\n    }\n    entries.splice(insertPosition + 1, 0, entry);\n  }\n\n  remove(type, handler) {\n    const {handlers, handlersByElement} = this;\n\n    for (let i = handlers.length - 1; i >= 0; i--) {\n      const entry = handlers[i];\n\n      if (entry.type === type && entry.handler === handler) {\n        handlers.splice(i, 1);\n        const entries = handlersByElement.get(entry.srcElement);\n        entries.splice(entries.indexOf(entry), 1);\n        if (entries.length === 0) {\n          handlersByElement.delete(entry.srcElement);\n        }\n      }\n    }\n    this._active = handlers.some(entry => !entry.passive);\n  }\n\n  /**\n   * Handles hammerjs event\n   */\n  handleEvent(event) {\n    if (this.isEmpty()) {\n      return;\n    }\n\n    const mjolnirEvent = this._normalizeEvent(event);\n    let target = event.srcEvent.target;\n\n    while (target && target !== mjolnirEvent.rootElement) {\n      this._emit(mjolnirEvent, target);\n      if (mjolnirEvent.handled) {\n        return;\n      }\n      target = target.parentNode;\n    }\n    this._emit(mjolnirEvent, 'root');\n  }\n\n  /**\n   * Invoke handlers on a particular element\n   */\n  _emit(event, srcElement) {\n    const entries = this.handlersByElement.get(srcElement);\n\n    if (entries) {\n      let immediatePropagationStopped = false;\n\n      // Prevents the current event from bubbling up\n      const stopPropagation = () => {\n        event.handled = true;\n      };\n      // Prevent any remaining listeners from being called\n      const stopImmediatePropagation = () => {\n        event.handled = true;\n        immediatePropagationStopped = true;\n      };\n      const entriesToRemove = [];\n\n      for (let i = 0; i < entries.length; i++) {\n        const {type, handler, once} = entries[i];\n        handler(\n          Object.assign({}, event, {\n            type,\n            stopPropagation,\n            stopImmediatePropagation\n          })\n        );\n        if (once) {\n          entriesToRemove.push(entries[i]);\n        }\n        if (immediatePropagationStopped) {\n          break;\n        }\n      }\n\n      for (let i = 0; i < entriesToRemove.length; i++) {\n        const {type, handler} = entriesToRemove[i];\n        this.remove(type, handler);\n      }\n    }\n  }\n\n  /**\n   * Normalizes hammerjs and custom events to have predictable fields.\n   */\n  _normalizeEvent(event) {\n    const rootElement = this.eventManager.element;\n\n    return Object.assign({}, event, whichButtons(event), getOffsetPosition(event, rootElement), {\n      handled: false,\n      rootElement\n    });\n  }\n}\n","// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Manager} from './utils/hammer';\n\nimport WheelInput from './inputs/wheel-input';\nimport MoveInput from './inputs/move-input';\nimport KeyInput from './inputs/key-input';\nimport ContextmenuInput from './inputs/contextmenu-input';\n\nimport EventRegistrar from './utils/event-registrar';\n\nimport {\n  BASIC_EVENT_ALIASES,\n  EVENT_RECOGNIZER_MAP,\n  GESTURE_EVENT_ALIASES,\n  RECOGNIZERS,\n  RECOGNIZER_COMPATIBLE_MAP,\n  RECOGNIZER_FALLBACK_MAP\n} from './constants';\n\nconst DEFAULT_OPTIONS = {\n  // event handlers\n  events: null,\n  // custom recognizers\n  recognizers: null,\n  recognizerOptions: {},\n  // Manager class\n  Manager,\n  // allow browser default touch action\n  // https://github.com/uber/react-map-gl/issues/506\n  touchAction: 'none',\n  tabIndex: 0\n};\n\n// Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\nexport default class EventManager {\n  constructor(element = null, options = {}) {\n    this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n    this.events = new Map();\n\n    this._onBasicInput = this._onBasicInput.bind(this);\n    this._onOtherEvent = this._onOtherEvent.bind(this);\n\n    this.setElement(element);\n\n    // Register all passed events.\n    const {events} = options;\n    if (events) {\n      this.on(events);\n    }\n  }\n\n  setElement(element) {\n    if (this.element) {\n      // unregister all events\n      this.destroy();\n    }\n    this.element = element;\n    if (!element) {\n      return;\n    }\n\n    const {options} = this;\n    const ManagerClass = options.Manager;\n\n    this.manager = new ManagerClass(element, {\n      touchAction: options.touchAction,\n      recognizers: options.recognizers || RECOGNIZERS\n    }).on('hammer.input', this._onBasicInput);\n\n    if (!options.recognizers) {\n      // Set default recognize withs\n      // http://hammerjs.github.io/recognize-with/\n      Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(name => {\n        const recognizer = this.manager.get(name);\n        if (recognizer) {\n          RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {\n            recognizer.recognizeWith(otherName);\n          });\n        }\n      });\n    }\n\n    // Set recognizer options\n    for (const recognizerName in options.recognizerOptions) {\n      const recognizer = this.manager.get(recognizerName);\n      if (recognizer) {\n        const recognizerOption = options.recognizerOptions[recognizerName];\n        // `enable` is managed by the event registrations\n        delete recognizerOption.enable;\n        recognizer.set(recognizerOption);\n      }\n    }\n\n    // Handle events not handled by Hammer.js:\n    // - mouse wheel\n    // - pointer/touch/mouse move\n    this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.moveInput = new MoveInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.keyInput = new KeyInput(element, this._onOtherEvent, {\n      enable: false,\n      tabIndex: options.tabIndex\n    });\n    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n      enable: false\n    });\n\n    // Register all existing events\n    for (const [eventAlias, eventRegistrar] of this.events) {\n      if (!eventRegistrar.isEmpty()) {\n        // Enable recognizer for this event.\n        this._toggleRecognizer(eventRegistrar.recognizerName, true);\n        this.manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n  }\n\n  // Tear down internal event management implementations.\n  destroy() {\n    if (this.element) {\n      // wheelInput etc. are created in setElement() and therefore\n      // cannot exist if there is no element\n      this.wheelInput.destroy();\n      this.moveInput.destroy();\n      this.keyInput.destroy();\n      this.contextmenuInput.destroy();\n      this.manager.destroy();\n\n      this.wheelInput = null;\n      this.moveInput = null;\n      this.keyInput = null;\n      this.contextmenuInput = null;\n      this.manager = null;\n      this.element = null;\n    }\n  }\n\n  // Register an event handler function to be called on `event`.\n  on(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false);\n  }\n\n  // Register an event handler function to be called on `event`, then remove it\n  once(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, true);\n  }\n\n  // Register an event handler function to be called on `event`\n  // This handler does not ask the event to be recognized at all times.\n  // Instead, it only \"intercepts\" the event if some other handler is getting it.\n  watch(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false, true);\n  }\n\n  /**\n   * Deregister a previously-registered event handler.\n   * @param {string|Object} event   An event name (String) or map of event names to handlers\n   * @param {Function} [handler]    The function to be called on `event`.\n   */\n  off(event, handler) {\n    this._removeEventHandler(event, handler);\n  }\n\n  /*\n   * Enable/disable recognizer for the given event\n   */\n  _toggleRecognizer(name, enabled) {\n    const {manager} = this;\n    if (!manager) {\n      return;\n    }\n    const recognizer = manager.get(name);\n    if (recognizer && recognizer.options.enable !== enabled) {\n      recognizer.set({enable: enabled});\n\n      const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];\n      if (fallbackRecognizers && !this.options.recognizers) {\n        // Set default require failures\n        // http://hammerjs.github.io/require-failure/\n        fallbackRecognizers.forEach(otherName => {\n          const otherRecognizer = manager.get(otherName);\n          if (enabled) {\n            // Wait for this recognizer to fail\n            otherRecognizer.requireFailure(name);\n            /**\n             * This seems to be a bug in hammerjs:\n             * requireFailure() adds both ways\n             * dropRequireFailure() only drops one way\n             * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/\n               recognizer-constructor.js#L136\n             */\n            recognizer.dropRequireFailure(otherName);\n          } else {\n            // Do not wait for this recognizer to fail\n            otherRecognizer.dropRequireFailure(name);\n          }\n        });\n      }\n    }\n    this.wheelInput.enableEventType(name, enabled);\n    this.moveInput.enableEventType(name, enabled);\n    this.keyInput.enableEventType(name, enabled);\n    this.contextmenuInput.enableEventType(name, enabled);\n  }\n\n  /**\n   * Process the event registration for a single event + handler.\n   */\n  _addEventHandler(event, handler, opts, once, passive) {\n    if (typeof event !== 'string') {\n      opts = handler;\n      // If `event` is a map, call `on()` for each entry.\n      for (const eventName in event) {\n        this._addEventHandler(eventName, event[eventName], opts, once, passive);\n      }\n      return;\n    }\n\n    const {manager, events} = this;\n    // Alias to a recognized gesture as necessary.\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n\n    let eventRegistrar = events.get(eventAlias);\n    if (!eventRegistrar) {\n      eventRegistrar = new EventRegistrar(this);\n      events.set(eventAlias, eventRegistrar);\n      // Enable recognizer for this event.\n      eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;\n      // Listen to the event\n      if (manager) {\n        manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n    eventRegistrar.add(event, handler, opts, once, passive);\n    if (!eventRegistrar.isEmpty()) {\n      this._toggleRecognizer(eventRegistrar.recognizerName, true);\n    }\n  }\n\n  /**\n   * Process the event deregistration for a single event + handler.\n   */\n  _removeEventHandler(event, handler) {\n    if (typeof event !== 'string') {\n      // If `event` is a map, call `off()` for each entry.\n      for (const eventName in event) {\n        this._removeEventHandler(eventName, event[eventName]);\n      }\n      return;\n    }\n\n    const {events} = this;\n    // Alias to a recognized gesture as necessary.\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n\n    const eventRegistrar = events.get(eventAlias);\n\n    if (!eventRegistrar) {\n      return;\n    }\n\n    eventRegistrar.remove(event, handler);\n\n    if (eventRegistrar.isEmpty()) {\n      const {recognizerName} = eventRegistrar;\n      // Disable recognizer if no more handlers are attached to its events\n      let isRecognizerUsed = false;\n      for (const eh of events.values()) {\n        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n          isRecognizerUsed = true;\n          break;\n        }\n      }\n      if (!isRecognizerUsed) {\n        this._toggleRecognizer(recognizerName, false);\n      }\n    }\n  }\n\n  /**\n   * Handle basic events using the 'hammer.input' Hammer.js API:\n   * Before running Recognizers, Hammer emits a 'hammer.input' event\n   * with the basic event info. This function emits all basic events\n   * aliased to the \"class\" of event received.\n   * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n   */\n  _onBasicInput(event) {\n    const {srcEvent} = event;\n    const alias = BASIC_EVENT_ALIASES[srcEvent.type];\n    if (alias) {\n      // fire all events aliased to srcEvent.type\n      this.manager.emit(alias, event);\n    }\n  }\n\n  /**\n   * Handle events not supported by Hammer.js,\n   * and pipe back out through same (Hammer) channel used by other events.\n   */\n  _onOtherEvent(event) {\n    // console.log('onotherevent', event.type, event)\n    this.manager.emit(event.type, event);\n  }\n}\n","// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport const EVENTS = [\n  'click',\n  'anyclick',\n  'contextmenu',\n  'pointerdown',\n  'pointermove',\n  'pointerup',\n  'pointerover',\n  'pointerout',\n  'pointerleave',\n  'doubletap',\n  'pinchin',\n  'pinchout',\n  'pinchstart',\n  'pinchmove',\n  'pinchend',\n  'pinchcancel',\n  'rotatestart',\n  'rotatemove',\n  'rotateend',\n  'rotatecancel',\n  'panstart',\n  'panmove',\n  'panend',\n  'pancancel',\n  'panup',\n  'pandown',\n  'panleft',\n  'panright',\n  'swipe',\n  'swipeleft',\n  'swiperight',\n  'swipeup',\n  'swipedown',\n  'keydown',\n  'keyup',\n  'wheel'\n];\n\nexport const INITIAL_OPTIONS = {\n  click: true,\n  doubletap: true,\n  pinchstart: true,\n  pinchmove: true,\n  pinchend: true,\n  rotatestart: true,\n  rotatemove: true,\n  rotateend: true,\n  panstart: true,\n  panmove: true,\n  panend: true,\n  wheel: true\n};\n","// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport React, {Component} from 'react';\nimport {render} from 'react-dom';\nimport {EventManager} from 'mjolnir.js';\n\nimport './style.css';\nimport {EVENTS, INITIAL_OPTIONS} from './constants';\n\nexport default class App extends Component {\n  constructor(props) {\n    super(props);\n\n    this._onLoad = this._onLoad.bind(this);\n    this._onLoadRedBox = this._onLoadRedBox.bind(this);\n    this._onUpdateOption = this._onUpdateOption.bind(this);\n    this._handleEvent = this._handleEvent.bind(this);\n    this._renderCheckbox = this._renderCheckbox.bind(this);\n\n    this.eventListeners = {};\n    EVENTS.forEach(eventName => {\n      if (INITIAL_OPTIONS[eventName]) {\n        this.eventListeners[eventName] = this._handleEvent;\n      }\n    });\n\n    this._eventManager = new EventManager(null, {\n      events: this.eventListeners\n    });\n\n    this.state = {\n      events: [],\n      options: INITIAL_OPTIONS\n    };\n  }\n\n  _onLoad(ref) {\n    this._eventManager.setElement(ref);\n  }\n\n  _onLoadRedBox(ref) {\n    if (ref) {\n      this._eventManager.on(this.eventListeners, ref);\n    }\n    this._redBox = ref;\n  }\n\n  _onUpdateOption(evt) {\n    const {name, checked} = evt.target;\n    if (checked) {\n      this.eventListeners[name] = this._handleEvent;\n      this._eventManager.on(name, this._handleEvent);\n      this._eventManager.on(name, this._handleEvent, this._redBox);\n    } else {\n      delete this.eventListeners[name];\n      this._eventManager.off(name, this._handleEvent);\n      this._eventManager.off(name, this._handleEvent, this._redBox);\n    }\n    this.setState({\n      options: Object.assign({}, this.state.options, {[name]: checked})\n    });\n  }\n\n  _handleEvent(evt) {\n    evt.preventDefault();\n    evt.stopPropagation();\n    const events = this.state.events.slice(0, 30);\n    events.unshift(evt);\n    this.setState({events});\n  }\n\n  _renderCheckbox(eventName) {\n    const {options} = this.state;\n    const id = `input-${eventName}`;\n\n    return (\n      <div key={eventName}>\n        <input\n          id={id}\n          type=\"checkbox\"\n          name={eventName}\n          checked={options[eventName] || false}\n          onChange={this._onUpdateOption}\n        />\n        <label htmlFor={id}>{eventName}</label>\n      </div>\n    );\n  }\n\n  _renderEvent(evt, index) {\n    return (\n      <div key={index}>\n        <span key=\"type\">{evt.type}</span>\n        <span key=\"position\">\n          {evt.offsetCenter\n            ? `(${evt.offsetCenter.x.toFixed(0)}, ${evt.offsetCenter.y.toFixed(0)})`\n            : ''}\n        </span>\n        <span key=\"button\">\n          {evt.key ||\n            (evt.leftButton && 'left button') ||\n            (evt.middleButton && 'middle button') ||\n            (evt.rightButton && 'right button')}\n        </span>\n        <span key=\"target\">{evt.target.id}</span>\n      </div>\n    );\n  }\n\n  render() {\n    const {events} = this.state;\n\n    return (\n      <div id=\"container\">\n        <div id=\"background\" ref={this._onLoad}>\n          <div id=\"red-box\" ref={this._onLoadRedBox} />\n        </div>\n\n        <div id=\"logs\">{events.map(this._renderEvent)}</div>\n\n        <div id=\"options\">{EVENTS.map(this._renderCheckbox)}</div>\n      </div>\n    );\n  }\n}\n\nexport function renderToDOM(container) {\n  render(<App />, container);\n}\n","/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function (window, document, exportName, undefined) {\n  'use strict';\n\n  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n  var TEST_ELEMENT = document.createElement('div');\n  var TYPE_FUNCTION = 'function';\n  var round = Math.round;\n  var abs = Math.abs;\n  var now = Date.now;\n  /**\n   * set a timeout with a given scope\n   * @param {Function} fn\n   * @param {Number} timeout\n   * @param {Object} context\n   * @returns {number}\n   */\n\n  function setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n  }\n  /**\n   * if the argument is an array, we want to execute the fn on each entry\n   * if it aint an array we don't want to do a thing.\n   * this is used by all the methods that accept a single and array argument.\n   * @param {*|Array} arg\n   * @param {String} fn\n   * @param {Object} [context]\n   * @returns {Boolean}\n   */\n\n\n  function invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n      each(arg, context[fn], context);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * walk objects and arrays\n   * @param {Object} obj\n   * @param {Function} iterator\n   * @param {Object} context\n   */\n\n\n  function each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n      return;\n    }\n\n    if (obj.forEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n      i = 0;\n\n      while (i < obj.length) {\n        iterator.call(context, obj[i], i, obj);\n        i++;\n      }\n    } else {\n      for (i in obj) {\n        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n      }\n    }\n  }\n  /**\n   * wrap a method with a deprecation warning and stack trace\n   * @param {Function} method\n   * @param {String} name\n   * @param {String} message\n   * @returns {Function} A new function wrapping the supplied method.\n   */\n\n\n  function deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function () {\n      var e = new Error('get-stack-trace');\n      var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n      var log = window.console && (window.console.warn || window.console.log);\n\n      if (log) {\n        log.call(window.console, deprecationMessage, stack);\n      }\n\n      return method.apply(this, arguments);\n    };\n  }\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} target\n   * @param {...Object} objects_to_assign\n   * @returns {Object} target\n   */\n\n\n  var assign;\n\n  if (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      var output = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var source = arguments[index];\n\n        if (source !== undefined && source !== null) {\n          for (var nextKey in source) {\n            if (source.hasOwnProperty(nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n\n      return output;\n    };\n  } else {\n    assign = Object.assign;\n  }\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} dest\n   * @param {Object} src\n   * @param {Boolean} [merge=false]\n   * @returns {Object} dest\n   */\n\n\n  var extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n\n    while (i < keys.length) {\n      if (!merge || merge && dest[keys[i]] === undefined) {\n        dest[keys[i]] = src[keys[i]];\n      }\n\n      i++;\n    }\n\n    return dest;\n  }, 'extend', 'Use `assign`.');\n  /**\n   * merge the values from src in the dest.\n   * means that properties that exist in dest will not be overwritten by src\n   * @param {Object} dest\n   * @param {Object} src\n   * @returns {Object} dest\n   */\n\n  var merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n  }, 'merge', 'Use `assign`.');\n  /**\n   * simple class inheritance\n   * @param {Function} child\n   * @param {Function} base\n   * @param {Object} [properties]\n   */\n\n  function inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n      assign(childP, properties);\n    }\n  }\n  /**\n   * simple function bind\n   * @param {Function} fn\n   * @param {Object} context\n   * @returns {Function}\n   */\n\n\n  function bindFn(fn, context) {\n    return function boundFn() {\n      return fn.apply(context, arguments);\n    };\n  }\n  /**\n   * let a boolean value also be a function that must return a boolean\n   * this first item in args will be used as the context\n   * @param {Boolean|Function} val\n   * @param {Array} [args]\n   * @returns {Boolean}\n   */\n\n\n  function boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n      return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n\n    return val;\n  }\n  /**\n   * use the val2 when val1 is undefined\n   * @param {*} val1\n   * @param {*} val2\n   * @returns {*}\n   */\n\n\n  function ifUndefined(val1, val2) {\n    return val1 === undefined ? val2 : val1;\n  }\n  /**\n   * addEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n\n\n  function addEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.addEventListener(type, handler, false);\n    });\n  }\n  /**\n   * removeEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n\n\n  function removeEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.removeEventListener(type, handler, false);\n    });\n  }\n  /**\n   * find if a node is in the given parent\n   * @method hasParent\n   * @param {HTMLElement} node\n   * @param {HTMLElement} parent\n   * @return {Boolean} found\n   */\n\n\n  function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n\n      node = node.parentNode;\n    }\n\n    return false;\n  }\n  /**\n   * small indexOf wrapper\n   * @param {String} str\n   * @param {String} find\n   * @returns {Boolean} found\n   */\n\n\n  function inStr(str, find) {\n    return str.indexOf(find) > -1;\n  }\n  /**\n   * split string on whitespace\n   * @param {String} str\n   * @returns {Array} words\n   */\n\n\n  function splitStr(str) {\n    return str.trim().split(/\\s+/g);\n  }\n  /**\n   * find if a array contains the object using indexOf or a simple polyFill\n   * @param {Array} src\n   * @param {String} find\n   * @param {String} [findByKey]\n   * @return {Boolean|Number} false when not found, or the index\n   */\n\n\n  function inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n      return src.indexOf(find);\n    } else {\n      var i = 0;\n\n      while (i < src.length) {\n        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n          return i;\n        }\n\n        i++;\n      }\n\n      return -1;\n    }\n  }\n  /**\n   * convert array-like objects to real arrays\n   * @param {Object} obj\n   * @returns {Array}\n   */\n\n\n  function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  }\n  /**\n   * unique array with objects based on a key (like 'id') or just by the array's value\n   * @param {Array} src [{id:1},{id:2},{id:1}]\n   * @param {String} [key]\n   * @param {Boolean} [sort=False]\n   * @returns {Array} [{id:1},{id:2}]\n   */\n\n\n  function uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n      var val = key ? src[i][key] : src[i];\n\n      if (inArray(values, val) < 0) {\n        results.push(src[i]);\n      }\n\n      values[i] = val;\n      i++;\n    }\n\n    if (sort) {\n      if (!key) {\n        results = results.sort();\n      } else {\n        results = results.sort(function sortUniqueArray(a, b) {\n          return a[key] > b[key];\n        });\n      }\n    }\n\n    return results;\n  }\n  /**\n   * get the prefixed property\n   * @param {Object} obj\n   * @param {String} property\n   * @returns {String|Undefined} prefixed\n   */\n\n\n  function prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n    var i = 0;\n\n    while (i < VENDOR_PREFIXES.length) {\n      prefix = VENDOR_PREFIXES[i];\n      prop = prefix ? prefix + camelProp : property;\n\n      if (prop in obj) {\n        return prop;\n      }\n\n      i++;\n    }\n\n    return undefined;\n  }\n  /**\n   * get a unique id\n   * @returns {number} uniqueId\n   */\n\n\n  var _uniqueId = 1;\n\n  function uniqueId() {\n    return _uniqueId++;\n  }\n  /**\n   * get the window object of an element\n   * @param {HTMLElement} element\n   * @returns {DocumentView|Window}\n   */\n\n\n  function getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return doc.defaultView || doc.parentWindow || window;\n  }\n\n  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n  var SUPPORT_TOUCH = ('ontouchstart' in window);\n  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n  var INPUT_TYPE_TOUCH = 'touch';\n  var INPUT_TYPE_PEN = 'pen';\n  var INPUT_TYPE_MOUSE = 'mouse';\n  var INPUT_TYPE_KINECT = 'kinect';\n  var COMPUTE_INTERVAL = 25;\n  var INPUT_START = 1;\n  var INPUT_MOVE = 2;\n  var INPUT_END = 4;\n  var INPUT_CANCEL = 8;\n  var DIRECTION_NONE = 1;\n  var DIRECTION_LEFT = 2;\n  var DIRECTION_RIGHT = 4;\n  var DIRECTION_UP = 8;\n  var DIRECTION_DOWN = 16;\n  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n  var PROPS_XY = ['x', 'y'];\n  var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n  /**\n   * create new input type manager\n   * @param {Manager} manager\n   * @param {Function} callback\n   * @returns {Input}\n   * @constructor\n   */\n\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n\n  Input.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function handler() {},\n\n    /**\n     * bind the events\n     */\n    init: function init() {\n      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function destroy() {\n      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n  };\n  /**\n   * create new input type manager\n   * called by the Manager constructor\n   * @param {Hammer} manager\n   * @returns {Input}\n   */\n\n  function createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n      Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n      Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n      Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n      Type = MouseInput;\n    } else {\n      Type = TouchMouseInput;\n    }\n\n    return new Type(manager, inputHandler);\n  }\n  /**\n   * handle input events\n   * @param {Manager} manager\n   * @param {String} eventType\n   * @param {Object} input\n   */\n\n\n  function inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n      manager.session = {};\n    } // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n\n\n    input.eventType = eventType; // compute scale, rotation etc\n\n    computeInputData(manager, input); // emit secret event\n\n    manager.emit('hammer.input', input);\n    manager.recognize(input);\n    manager.session.prevInput = input;\n  }\n  /**\n   * extend the data with some usable properties like scale, rotate, velocity etc\n   * @param {Object} manager\n   * @param {Object} input\n   */\n\n\n  function computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length; // store the first input to calculate the distance and direction\n\n    if (!session.firstInput) {\n      session.firstInput = simpleCloneInputData(input);\n    } // to compute scale and rotation we need to store the multiple touches\n\n\n    if (pointersLength > 1 && !session.firstMultiple) {\n      session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n      session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n    input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n    computeIntervalInputData(session, input); // find the correct target\n\n    var target = manager.element;\n\n    if (hasParent(input.srcEvent.target, target)) {\n      target = input.srcEvent.target;\n    }\n\n    input.target = target;\n  }\n\n  function computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n      prevDelta = session.prevDelta = {\n        x: prevInput.deltaX || 0,\n        y: prevInput.deltaY || 0\n      };\n      offset = session.offsetDelta = {\n        x: center.x,\n        y: center.y\n      };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n  }\n  /**\n   * velocity is calculated every x ms\n   * @param {Object} session\n   * @param {Object} input\n   */\n\n\n  function computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity,\n        velocityX,\n        velocityY,\n        direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n      var deltaX = input.deltaX - last.deltaX;\n      var deltaY = input.deltaY - last.deltaY;\n      var v = getVelocity(deltaTime, deltaX, deltaY);\n      velocityX = v.x;\n      velocityY = v.y;\n      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n      direction = getDirection(deltaX, deltaY);\n      session.lastInterval = input;\n    } else {\n      // use latest velocity info if it doesn't overtake a minimum period\n      velocity = last.velocity;\n      velocityX = last.velocityX;\n      velocityY = last.velocityY;\n      direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n  }\n  /**\n   * create a simple clone from the input used for storage of firstInput and firstMultiple\n   * @param {Object} input\n   * @returns {Object} clonedInputData\n   */\n\n\n  function simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n\n    while (i < input.pointers.length) {\n      pointers[i] = {\n        clientX: round(input.pointers[i].clientX),\n        clientY: round(input.pointers[i].clientY)\n      };\n      i++;\n    }\n\n    return {\n      timeStamp: now(),\n      pointers: pointers,\n      center: getCenter(pointers),\n      deltaX: input.deltaX,\n      deltaY: input.deltaY\n    };\n  }\n  /**\n   * get the center of all the pointers\n   * @param {Array} pointers\n   * @return {Object} center contains `x` and `y` properties\n   */\n\n\n  function getCenter(pointers) {\n    var pointersLength = pointers.length; // no need to loop when only one touch\n\n    if (pointersLength === 1) {\n      return {\n        x: round(pointers[0].clientX),\n        y: round(pointers[0].clientY)\n      };\n    }\n\n    var x = 0,\n        y = 0,\n        i = 0;\n\n    while (i < pointersLength) {\n      x += pointers[i].clientX;\n      y += pointers[i].clientY;\n      i++;\n    }\n\n    return {\n      x: round(x / pointersLength),\n      y: round(y / pointersLength)\n    };\n  }\n  /**\n   * calculate the velocity between two points. unit is in px per ms.\n   * @param {Number} deltaTime\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Object} velocity `x` and `y`\n   */\n\n\n  function getVelocity(deltaTime, x, y) {\n    return {\n      x: x / deltaTime || 0,\n      y: y / deltaTime || 0\n    };\n  }\n  /**\n   * get the direction between two points\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Number} direction\n   */\n\n\n  function getDirection(x, y) {\n    if (x === y) {\n      return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  }\n  /**\n   * calculate the absolute distance between two points\n   * @param {Object} p1 {x, y}\n   * @param {Object} p2 {x, y}\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} distance\n   */\n\n\n  function getDistance(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.sqrt(x * x + y * y);\n  }\n  /**\n   * calculate the angle between two coordinates\n   * @param {Object} p1\n   * @param {Object} p2\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} angle\n   */\n\n\n  function getAngle(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n  }\n  /**\n   * calculate the rotation degrees between two pointersets\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} rotation\n   */\n\n\n  function getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n  }\n  /**\n   * calculate the scale factor between two pointersets\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} scale\n   */\n\n\n  function getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n  }\n\n  var MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n  };\n  var MOUSE_ELEMENT_EVENTS = 'mousedown';\n  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n  /**\n   * Mouse events input\n   * @constructor\n   * @extends Input\n   */\n\n  function MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n  }\n\n  inherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n      var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down\n\n      if (eventType & INPUT_START && ev.button === 0) {\n        this.pressed = true;\n      }\n\n      if (eventType & INPUT_MOVE && ev.which !== 1) {\n        eventType = INPUT_END;\n      } // mouse must be down\n\n\n      if (!this.pressed) {\n        return;\n      }\n\n      if (eventType & INPUT_END) {\n        this.pressed = false;\n      }\n\n      this.callback(this.manager, eventType, {\n        pointers: [ev],\n        changedPointers: [ev],\n        pointerType: INPUT_TYPE_MOUSE,\n        srcEvent: ev\n      });\n    }\n  });\n  var POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n  }; // in IE10 the pointer types is defined as an enum\n\n  var IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\n  };\n  var POINTER_ELEMENT_EVENTS = 'pointerdown';\n  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive\n\n  if (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n  }\n  /**\n   * Pointer events input\n   * @constructor\n   * @extends Input\n   */\n\n\n  function PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n    Input.apply(this, arguments);\n    this.store = this.manager.session.pointerEvents = [];\n  }\n\n  inherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n      var store = this.store;\n      var removePointer = false;\n      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n      var isTouch = pointerType == INPUT_TYPE_TOUCH; // get index of the event in the store\n\n      var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n        if (storeIndex < 0) {\n          store.push(ev);\n          storeIndex = store.length - 1;\n        }\n      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        removePointer = true;\n      } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n\n      if (storeIndex < 0) {\n        return;\n      } // update the event in the store\n\n\n      store[storeIndex] = ev;\n      this.callback(this.manager, eventType, {\n        pointers: store,\n        changedPointers: [ev],\n        pointerType: pointerType,\n        srcEvent: ev\n      });\n\n      if (removePointer) {\n        // remove from the store\n        store.splice(storeIndex, 1);\n      }\n    }\n  });\n  var SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n  /**\n   * Touch events input\n   * @constructor\n   * @extends Input\n   */\n\n  function SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n    Input.apply(this, arguments);\n  }\n\n  inherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n      var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?\n\n      if (type === INPUT_START) {\n        this.started = true;\n      }\n\n      if (!this.started) {\n        return;\n      }\n\n      var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state\n\n      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n        this.started = false;\n      }\n\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n\n  function normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n  }\n\n  var TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n  /**\n   * Multi-user touch events input\n   * @constructor\n   * @extends Input\n   */\n\n  function TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n    Input.apply(this, arguments);\n  }\n\n  inherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n      var type = TOUCH_INPUT_MAP[ev.type];\n      var touches = getTouches.call(this, ev, type);\n\n      if (!touches) {\n        return;\n      }\n\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n\n  function getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds; // when there is only one touch, the process can be simplified\n\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n      targetIds[allTouches[0].identifier] = true;\n      return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target; // get target touches from touches\n\n    targetTouches = allTouches.filter(function (touch) {\n      return hasParent(touch.target, target);\n    }); // collect touches\n\n    if (type === INPUT_START) {\n      i = 0;\n\n      while (i < targetTouches.length) {\n        targetIds[targetTouches[i].identifier] = true;\n        i++;\n      }\n    } // filter changed touches to only contain touches that exist in the collected target ids\n\n\n    i = 0;\n\n    while (i < changedTouches.length) {\n      if (targetIds[changedTouches[i].identifier]) {\n        changedTargetTouches.push(changedTouches[i]);\n      } // cleanup removed touches\n\n\n      if (type & (INPUT_END | INPUT_CANCEL)) {\n        delete targetIds[changedTouches[i].identifier];\n      }\n\n      i++;\n    }\n\n    if (!changedTargetTouches.length) {\n      return;\n    }\n\n    return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n  }\n  /**\n   * Combined touch and mouse input\n   *\n   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n   * This because touch devices also emit mouse events while doing a touch.\n   *\n   * @constructor\n   * @extends Input\n   */\n\n\n  var DEDUP_TIMEOUT = 2500;\n  var DEDUP_DISTANCE = 25;\n\n  function TouchMouseInput() {\n    Input.apply(this, arguments);\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n    this.primaryTouch = null;\n    this.lastTouches = [];\n  }\n\n  inherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n      var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,\n          isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;\n\n      if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n        return;\n      } // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\n\n      if (isTouch) {\n        recordTouches.call(this, inputEvent, inputData);\n      } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n        return;\n      }\n\n      this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    }\n  });\n\n  function recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n      this.primaryTouch = eventData.changedPointers[0].identifier;\n      setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      setLastTouch.call(this, eventData);\n    }\n  }\n\n  function setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n      var lastTouch = {\n        x: touch.clientX,\n        y: touch.clientY\n      };\n      this.lastTouches.push(lastTouch);\n      var lts = this.lastTouches;\n\n      var removeLastTouch = function removeLastTouch() {\n        var i = lts.indexOf(lastTouch);\n\n        if (i > -1) {\n          lts.splice(i, 1);\n        }\n      };\n\n      setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n  }\n\n  function isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX,\n        y = eventData.srcEvent.clientY;\n\n    for (var i = 0; i < this.lastTouches.length; i++) {\n      var t = this.lastTouches[i];\n      var dx = Math.abs(x - t.x),\n          dy = Math.abs(y - t.y);\n\n      if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined; // magical touchAction value\n\n  var TOUCH_ACTION_COMPUTE = 'compute';\n  var TOUCH_ACTION_AUTO = 'auto';\n  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\n  var TOUCH_ACTION_NONE = 'none';\n  var TOUCH_ACTION_PAN_X = 'pan-x';\n  var TOUCH_ACTION_PAN_Y = 'pan-y';\n  var TOUCH_ACTION_MAP = getTouchActionProps();\n  /**\n   * Touch Action\n   * sets the touchAction property or uses the js alternative\n   * @param {Manager} manager\n   * @param {String} value\n   * @constructor\n   */\n\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n\n  TouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function set(value) {\n      // find out the touch-action by the event handlers\n      if (value == TOUCH_ACTION_COMPUTE) {\n        value = this.compute();\n      }\n\n      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n      }\n\n      this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function update() {\n      this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function compute() {\n      var actions = [];\n      each(this.manager.recognizers, function (recognizer) {\n        if (boolOrFn(recognizer.options.enable, [recognizer])) {\n          actions = actions.concat(recognizer.getTouchAction());\n        }\n      });\n      return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function preventDefaults(input) {\n      var srcEvent = input.srcEvent;\n      var direction = input.offsetDirection; // if the touch action did prevented once this session\n\n      if (this.manager.session.prevented) {\n        srcEvent.preventDefault();\n        return;\n      }\n\n      var actions = this.actions;\n      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n      if (hasNone) {\n        //do not prevent defaults if this is a tap gesture\n        var isTapPointer = input.pointers.length === 1;\n        var isTapMovement = input.distance < 2;\n        var isTapTouchTime = input.deltaTime < 250;\n\n        if (isTapPointer && isTapMovement && isTapTouchTime) {\n          return;\n        }\n      }\n\n      if (hasPanX && hasPanY) {\n        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n        return;\n      }\n\n      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n        return this.preventSrc(srcEvent);\n      }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function preventSrc(srcEvent) {\n      this.manager.session.prevented = true;\n      srcEvent.preventDefault();\n    }\n  };\n  /**\n   * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n   * @param {String} actions\n   * @returns {*}\n   */\n\n  function cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n      return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n\n    if (hasPanX && hasPanY) {\n      return TOUCH_ACTION_NONE;\n    } // pan-x OR pan-y\n\n\n    if (hasPanX || hasPanY) {\n      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    } // manipulation\n\n\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n      return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n  }\n\n  function getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n      return false;\n    }\n\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n      // If css.supports is not supported but there is native touch-action assume it supports\n      // all values. This is the case for IE 10 and 11.\n      touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n  }\n  /**\n   * Recognizer flow explained; *\n   * All recognizers have the initial state of POSSIBLE when a input session starts.\n   * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n   * Example session for mouse-input: mousedown -> mousemove -> mouseup\n   *\n   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n   * which determines with state it should be.\n   *\n   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n   * POSSIBLE to give it another change on the next cycle.\n   *\n   *               Possible\n   *                  |\n   *            +-----+---------------+\n   *            |                     |\n   *      +-----+-----+               |\n   *      |           |               |\n   *   Failed      Cancelled          |\n   *                          +-------+------+\n   *                          |              |\n   *                      Recognized       Began\n   *                                         |\n   *                                      Changed\n   *                                         |\n   *                                  Ended/Recognized\n   */\n\n\n  var STATE_POSSIBLE = 1;\n  var STATE_BEGAN = 2;\n  var STATE_CHANGED = 4;\n  var STATE_ENDED = 8;\n  var STATE_RECOGNIZED = STATE_ENDED;\n  var STATE_CANCELLED = 16;\n  var STATE_FAILED = 32;\n  /**\n   * Recognizer\n   * Every recognizer needs to extend from this class.\n   * @constructor\n   * @param {Object} options\n   */\n\n  function Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n    this.id = uniqueId();\n    this.manager = null; // default is enable true\n\n    this.options.enable = ifUndefined(this.options.enable, true);\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  Recognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function set(options) {\n      assign(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n      this.manager && this.manager.touchAction.update();\n      return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function recognizeWith(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n        return this;\n      }\n\n      var simultaneous = this.simultaneous;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n      if (!simultaneous[otherRecognizer.id]) {\n        simultaneous[otherRecognizer.id] = otherRecognizer;\n        otherRecognizer.recognizeWith(this);\n      }\n\n      return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      delete this.simultaneous[otherRecognizer.id];\n      return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function requireFailure(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n        return this;\n      }\n\n      var requireFail = this.requireFail;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n      if (inArray(requireFail, otherRecognizer) === -1) {\n        requireFail.push(otherRecognizer);\n        otherRecognizer.requireFailure(this);\n      }\n\n      return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function dropRequireFailure(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      var index = inArray(this.requireFail, otherRecognizer);\n\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n\n      return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function hasRequireFailures() {\n      return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function canRecognizeWith(otherRecognizer) {\n      return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function emit(input) {\n      var self = this;\n      var state = this.state;\n\n      function emit(event) {\n        self.manager.emit(event, input);\n      } // 'panstart' and 'panmove'\n\n\n      if (state < STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n\n      emit(self.options.event); // simple 'eventName' events\n\n      if (input.additionalEvent) {\n        // additional event(panleft, panright, pinchin, pinchout...)\n        emit(input.additionalEvent);\n      } // panend and pancancel\n\n\n      if (state >= STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function tryEmit(input) {\n      if (this.canEmit()) {\n        return this.emit(input);\n      } // it's failing anyway\n\n\n      this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function canEmit() {\n      var i = 0;\n\n      while (i < this.requireFail.length) {\n        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n          return false;\n        }\n\n        i++;\n      }\n\n      return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function recognize(inputData) {\n      // make a new copy of the inputData\n      // so we can change the inputData without messing up the other recognizers\n      var inputDataClone = assign({}, inputData); // is is enabled and allow recognizing?\n\n      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n        this.reset();\n        this.state = STATE_FAILED;\n        return;\n      } // reset when we've reached the end\n\n\n      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n        this.state = STATE_POSSIBLE;\n      }\n\n      this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n      // so trigger an event\n\n      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n        this.tryEmit(inputDataClone);\n      }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function process(inputData) {},\n    // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function getTouchAction() {},\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function reset() {}\n  };\n  /**\n   * get a usable string, used as event postfix\n   * @param {Const} state\n   * @returns {String} state\n   */\n\n  function stateStr(state) {\n    if (state & STATE_CANCELLED) {\n      return 'cancel';\n    } else if (state & STATE_ENDED) {\n      return 'end';\n    } else if (state & STATE_CHANGED) {\n      return 'move';\n    } else if (state & STATE_BEGAN) {\n      return 'start';\n    }\n\n    return '';\n  }\n  /**\n   * direction cons to string\n   * @param {Const} direction\n   * @returns {String}\n   */\n\n\n  function directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n      return 'down';\n    } else if (direction == DIRECTION_UP) {\n      return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n      return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n      return 'right';\n    }\n\n    return '';\n  }\n  /**\n   * get a recognizer by name if it is bound to a manager\n   * @param {Recognizer|String} otherRecognizer\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer}\n   */\n\n\n  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n\n    if (manager) {\n      return manager.get(otherRecognizer);\n    }\n\n    return otherRecognizer;\n  }\n  /**\n   * This recognizer is just used as a base for the simple attribute recognizers.\n   * @constructor\n   * @extends Recognizer\n   */\n\n\n  function AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n  }\n\n  inherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n      /**\n       * @type {Number}\n       * @default 1\n       */\n      pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function attrTest(input) {\n      var optionPointers = this.options.pointers;\n      return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function process(input) {\n      var state = this.state;\n      var eventType = input.eventType;\n      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n      var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n        return state | STATE_CANCELLED;\n      } else if (isRecognized || isValid) {\n        if (eventType & INPUT_END) {\n          return state | STATE_ENDED;\n        } else if (!(state & STATE_BEGAN)) {\n          return STATE_BEGAN;\n        }\n\n        return state | STATE_CHANGED;\n      }\n\n      return STATE_FAILED;\n    }\n  });\n  /**\n   * Pan\n   * Recognized when the pointer is down and moved in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n    this.pX = null;\n    this.pY = null;\n  }\n\n  inherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    },\n    getTouchAction: function getTouchAction() {\n      var direction = this.options.direction;\n      var actions = [];\n\n      if (direction & DIRECTION_HORIZONTAL) {\n        actions.push(TOUCH_ACTION_PAN_Y);\n      }\n\n      if (direction & DIRECTION_VERTICAL) {\n        actions.push(TOUCH_ACTION_PAN_X);\n      }\n\n      return actions;\n    },\n    directionTest: function directionTest(input) {\n      var options = this.options;\n      var hasMoved = true;\n      var distance = input.distance;\n      var direction = input.direction;\n      var x = input.deltaX;\n      var y = input.deltaY; // lock to axis?\n\n      if (!(direction & options.direction)) {\n        if (options.direction & DIRECTION_HORIZONTAL) {\n          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          hasMoved = x != this.pX;\n          distance = Math.abs(input.deltaX);\n        } else {\n          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n          hasMoved = y != this.pY;\n          distance = Math.abs(input.deltaY);\n        }\n      }\n\n      input.direction = direction;\n      return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n    attrTest: function attrTest(input) {\n      return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n    },\n    emit: function emit(input) {\n      this.pX = input.deltaX;\n      this.pY = input.deltaY;\n      var direction = directionStr(input.direction);\n\n      if (direction) {\n        input.additionalEvent = this.options.event + direction;\n      }\n\n      this._super.emit.call(this, input);\n    }\n  });\n  /**\n   * Pinch\n   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function attrTest(input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n    emit: function emit(input) {\n      if (input.scale !== 1) {\n        var inOut = input.scale < 1 ? 'in' : 'out';\n        input.additionalEvent = this.options.event + inOut;\n      }\n\n      this._super.emit.call(this, input);\n    }\n  });\n  /**\n   * Press\n   * Recognized when the pointer is down for x ms without any movement.\n   * @constructor\n   * @extends Recognizer\n   */\n\n  function PressRecognizer() {\n    Recognizer.apply(this, arguments);\n    this._timer = null;\n    this._input = null;\n  }\n\n  inherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9 // a minimal movement is ok, but keep it low\n\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_AUTO];\n    },\n    process: function process(input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTime = input.deltaTime > options.time;\n      this._input = input; // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n\n      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n        this.reset();\n      } else if (input.eventType & INPUT_START) {\n        this.reset();\n        this._timer = setTimeoutContext(function () {\n          this.state = STATE_RECOGNIZED;\n          this.tryEmit();\n        }, options.time, this);\n      } else if (input.eventType & INPUT_END) {\n        return STATE_RECOGNIZED;\n      }\n\n      return STATE_FAILED;\n    },\n    reset: function reset() {\n      clearTimeout(this._timer);\n    },\n    emit: function emit(input) {\n      if (this.state !== STATE_RECOGNIZED) {\n        return;\n      }\n\n      if (input && input.eventType & INPUT_END) {\n        this.manager.emit(this.options.event + 'up', input);\n      } else {\n        this._input.timeStamp = now();\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n  /**\n   * Rotate\n   * Recognized when two or more pointer are moving in a circular motion.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function attrTest(input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n  });\n  /**\n   * Swipe\n   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    },\n    getTouchAction: function getTouchAction() {\n      return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n    attrTest: function attrTest(input) {\n      var direction = this.options.direction;\n      var velocity;\n\n      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n        velocity = input.overallVelocity;\n      } else if (direction & DIRECTION_HORIZONTAL) {\n        velocity = input.overallVelocityX;\n      } else if (direction & DIRECTION_VERTICAL) {\n        velocity = input.overallVelocityY;\n      }\n\n      return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n    emit: function emit(input) {\n      var direction = directionStr(input.offsetDirection);\n\n      if (direction) {\n        this.manager.emit(this.options.event + direction, input);\n      }\n\n      this.manager.emit(this.options.event, input);\n    }\n  });\n  /**\n   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n   * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n   * a single tap.\n   *\n   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n   * multi-taps being recognized.\n   * @constructor\n   * @extends Recognizer\n   */\n\n  function TapRecognizer() {\n    Recognizer.apply(this, arguments); // previous time and center,\n    // used for tap counting\n\n    this.pTime = false;\n    this.pCenter = false;\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n\n  inherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10 // a multi-tap can be a bit off the initial position\n\n    },\n    getTouchAction: function getTouchAction() {\n      return [TOUCH_ACTION_MANIPULATION];\n    },\n    process: function process(input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTouchTime = input.deltaTime < options.time;\n      this.reset();\n\n      if (input.eventType & INPUT_START && this.count === 0) {\n        return this.failTimeout();\n      } // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n\n\n      if (validMovement && validTouchTime && validPointers) {\n        if (input.eventType != INPUT_END) {\n          return this.failTimeout();\n        }\n\n        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n        this.pTime = input.timeStamp;\n        this.pCenter = input.center;\n\n        if (!validMultiTap || !validInterval) {\n          this.count = 1;\n        } else {\n          this.count += 1;\n        }\n\n        this._input = input; // if tap count matches we have recognized it,\n        // else it has began recognizing...\n\n        var tapCount = this.count % options.taps;\n\n        if (tapCount === 0) {\n          // no failing requirements, immediately trigger the tap event\n          // or wait as long as the multitap interval to trigger\n          if (!this.hasRequireFailures()) {\n            return STATE_RECOGNIZED;\n          } else {\n            this._timer = setTimeoutContext(function () {\n              this.state = STATE_RECOGNIZED;\n              this.tryEmit();\n            }, options.interval, this);\n            return STATE_BEGAN;\n          }\n        }\n      }\n\n      return STATE_FAILED;\n    },\n    failTimeout: function failTimeout() {\n      this._timer = setTimeoutContext(function () {\n        this.state = STATE_FAILED;\n      }, this.options.interval, this);\n      return STATE_FAILED;\n    },\n    reset: function reset() {\n      clearTimeout(this._timer);\n    },\n    emit: function emit() {\n      if (this.state == STATE_RECOGNIZED) {\n        this._input.tapCount = this.count;\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n  /**\n   * Simple way to create a manager with a default set of recognizers.\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n\n  function Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n  }\n  /**\n   * @const {string}\n   */\n\n\n  Hammer.VERSION = '2.0.7';\n  /**\n   * default settings\n   * @namespace\n   */\n\n  Hammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n    [RotateRecognizer, {\n      enable: false\n    }], [PinchRecognizer, {\n      enable: false\n    }, ['rotate']], [SwipeRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }], [PanRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }, ['swipe']], [TapRecognizer], [TapRecognizer, {\n      event: 'doubletap',\n      taps: 2\n    }, ['tap']], [PressRecognizer]],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n      /**\n       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userSelect: 'none',\n\n      /**\n       * Disable the Windows Phone grippers when pressing an element.\n       * @type {String}\n       * @default 'none'\n       */\n      touchSelect: 'none',\n\n      /**\n       * Disables the default callout shown when you touch and hold a touch target.\n       * On iOS, when you touch and hold a touch target such as a link, Safari displays\n       * a callout containing information about the link. This property allows you to disable that callout.\n       * @type {String}\n       * @default 'none'\n       */\n      touchCallout: 'none',\n\n      /**\n       * Specifies whether zooming is enabled. Used by IE10>\n       * @type {String}\n       * @default 'none'\n       */\n      contentZooming: 'none',\n\n      /**\n       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userDrag: 'none',\n\n      /**\n       * Overrides the highlight color shown when the user taps a link or a JavaScript\n       * clickable element in iOS. This property obeys the alpha value, if specified.\n       * @type {String}\n       * @default 'rgba(0,0,0,0)'\n       */\n      tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n  };\n  var STOP = 1;\n  var FORCED_STOP = 2;\n  /**\n   * Manager\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n\n  function Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = this.add(new item[0](item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n\n  Manager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function set(options) {\n      assign(this.options, options); // Options that need a little more setup\n\n      if (options.touchAction) {\n        this.touchAction.update();\n      }\n\n      if (options.inputTarget) {\n        // Clean up existing event listeners and reinitialize\n        this.input.destroy();\n        this.input.target = options.inputTarget;\n        this.input.init();\n      }\n\n      return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function stop(force) {\n      this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function recognize(inputData) {\n      var session = this.session;\n\n      if (session.stopped) {\n        return;\n      } // run the touch-action polyfill\n\n\n      this.touchAction.preventDefaults(inputData);\n      var recognizer;\n      var recognizers = this.recognizers; // this holds the recognizer that is being recognized.\n      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n      // if no recognizer is detecting a thing, it is set to `null`\n\n      var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized\n      // or when we're in a new session\n\n      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n        curRecognizer = session.curRecognizer = null;\n      }\n\n      var i = 0;\n\n      while (i < recognizers.length) {\n        recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n        // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n        //      that is being recognized.\n        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n        //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n        if (session.stopped !== FORCED_STOP && ( // 1\n        !curRecognizer || recognizer == curRecognizer || // 2\n        recognizer.canRecognizeWith(curRecognizer))) {\n          // 3\n          recognizer.recognize(inputData);\n        } else {\n          recognizer.reset();\n        } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n        // current active recognizer. but only if we don't already have an active recognizer\n\n\n        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n          curRecognizer = session.curRecognizer = recognizer;\n        }\n\n        i++;\n      }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function get(recognizer) {\n      if (recognizer instanceof Recognizer) {\n        return recognizer;\n      }\n\n      var recognizers = this.recognizers;\n\n      for (var i = 0; i < recognizers.length; i++) {\n        if (recognizers[i].options.event == recognizer) {\n          return recognizers[i];\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function add(recognizer) {\n      if (invokeArrayArg(recognizer, 'add', this)) {\n        return this;\n      } // remove existing\n\n\n      var existing = this.get(recognizer.options.event);\n\n      if (existing) {\n        this.remove(existing);\n      }\n\n      this.recognizers.push(recognizer);\n      recognizer.manager = this;\n      this.touchAction.update();\n      return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function remove(recognizer) {\n      if (invokeArrayArg(recognizer, 'remove', this)) {\n        return this;\n      }\n\n      recognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n      if (recognizer) {\n        var recognizers = this.recognizers;\n        var index = inArray(recognizers, recognizer);\n\n        if (index !== -1) {\n          recognizers.splice(index, 1);\n          this.touchAction.update();\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function on(events, handler) {\n      if (events === undefined) {\n        return;\n      }\n\n      if (handler === undefined) {\n        return;\n      }\n\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        handlers[event] = handlers[event] || [];\n        handlers[event].push(handler);\n      });\n      return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function off(events, handler) {\n      if (events === undefined) {\n        return;\n      }\n\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        if (!handler) {\n          delete handlers[event];\n        } else {\n          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n        }\n      });\n      return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function emit(event, data) {\n      // we also want to trigger dom events\n      if (this.options.domEvents) {\n        triggerDomEvent(event, data);\n      } // no handlers, so skip it all\n\n\n      var handlers = this.handlers[event] && this.handlers[event].slice();\n\n      if (!handlers || !handlers.length) {\n        return;\n      }\n\n      data.type = event;\n\n      data.preventDefault = function () {\n        data.srcEvent.preventDefault();\n      };\n\n      var i = 0;\n\n      while (i < handlers.length) {\n        handlers[i](data);\n        i++;\n      }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function destroy() {\n      this.element && toggleCssProps(this, false);\n      this.handlers = {};\n      this.session = {};\n      this.input.destroy();\n      this.element = null;\n    }\n  };\n  /**\n   * add/remove the css properties as defined in manager.options.cssProps\n   * @param {Manager} manager\n   * @param {Boolean} add\n   */\n\n  function toggleCssProps(manager, add) {\n    var element = manager.element;\n\n    if (!element.style) {\n      return;\n    }\n\n    var prop;\n    each(manager.options.cssProps, function (value, name) {\n      prop = prefixed(element.style, name);\n\n      if (add) {\n        manager.oldCssProps[prop] = element.style[prop];\n        element.style[prop] = value;\n      } else {\n        element.style[prop] = manager.oldCssProps[prop] || '';\n      }\n    });\n\n    if (!add) {\n      manager.oldCssProps = {};\n    }\n  }\n  /**\n   * trigger dom event\n   * @param {String} event\n   * @param {Object} data\n   */\n\n\n  function triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n  }\n\n  assign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n  }); // this prevents errors when Hammer is loaded in the presence of an AMD\n  //  style loader but by script tag, not by the loader.\n\n  var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line\n\n  freeGlobal.Hammer = Hammer;\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return Hammer;\n    });\n  } else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n  } else {\n    window[exportName] = Hammer;\n  }\n})(window, document, 'Hammer');","// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global'\n\n/* global window, global, document, navigator */\nexport const userAgent =\n  typeof navigator !== 'undefined' && navigator.userAgent ? navigator.userAgent.toLowerCase() : '';\n\nconst window_ = typeof window !== 'undefined' ? window : global;\nconst global_ = typeof global !== 'undefined' ? global : window;\nconst document_ = typeof document !== 'undefined' ? document : {};\n\nexport {window_ as window, global_ as global, document_ as document};\n\n/*\n * Detect whether passive option is supported by the current browser.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n   #Safely_detecting_option_support\n */\nlet passiveSupported = false;\n\n/* eslint-disable accessor-pairs, no-empty */\ntry {\n  const options = {\n    // This function will be called when the browser\n    // attempts to access the passive property.\n    get passive() {\n      passiveSupported = true;\n      return true;\n    }\n  };\n\n  window_.addEventListener('test', options, options);\n  window_.removeEventListener('test', options, options);\n} catch (err) {}\n\nexport {passiveSupported};\n"],"sourceRoot":""}